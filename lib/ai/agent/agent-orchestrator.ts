/**
 * Agent Orchestrator - Coordinate parent agents and their sub-agents
 * 
 * Features:
 * - Manage agent hierarchies (parent -> sub-agents)
 * - Coordinate parallel and sequential execution
 * - Handle result aggregation and context sharing
 * - Support for dynamic sub-agent creation during execution
 */

import { nanoid } from 'nanoid';
import { generateText } from 'ai';
import { getProviderModel, type ProviderName } from '../core/client';
import { type AgentResult, type AgentTool, type ToolCall } from './agent-executor';
import {
  createSubAgent,
  executeSubAgentsParallel,
  executeSubAgentsSequential,
  cancelAllSubAgents,
  type SubAgentExecutorConfig,
} from './sub-agent-executor';
import type {
  SubAgent,
  SubAgentConfig,
  SubAgentResult,
  SubAgentExecutionOptions,
  SubAgentOrchestrationResult,
  SubAgentExecutionMode,
} from '@/types/agent/sub-agent';
import type {
  ExternalAgentDelegationRule,
  ExternalAgentDelegationResult,
  ExternalAgentExecutionOptions,
} from '@/types/agent/external-agent';
import { loggers } from '@/lib/logger';

const log = loggers.agent;

/**
 * Orchestrator configuration
 */
export interface OrchestratorConfig {
  provider: ProviderName;
  model: string;
  apiKey: string;
  baseURL?: string;
  systemPrompt?: string;
  temperature?: number;
  maxSteps?: number;
  maxSubAgents?: number;
  maxConcurrentSubAgents?: number;
  defaultSubAgentConfig?: Partial<SubAgentConfig>;
  tools?: Record<string, AgentTool>;
  enableAutoPlanning?: boolean;
  enableDynamicSubAgents?: boolean;
  
  // === Smart Routing (Claude Best Practice) ===
  // Multi-agent systems use 3-10x more tokens than single-agent approaches.
  // Only use multi-agent when: context pollution, parallelization, or specialization is needed.
  
  /** Enable smart routing to decide single vs multi-agent automatically */
  enableSmartRouting?: boolean;
  /** Threshold for preferring single agent (0-1, higher = more likely single agent) */
  singleAgentThreshold?: number;
  /** Maximum estimated tokens before forcing multi-agent (for context isolation) */
  contextIsolationThreshold?: number;
  
  // === Token Budget Awareness (Claude Best Practice) ===
  // Multi-agent systems use 3-10x more tokens than single-agent approaches.
  // Plan generation should respect token budgets to ensure predictable costs.
  
  /** Maximum total token budget for the entire orchestration */
  maxTokenBudget?: number;
  /** Estimated tokens per sub-agent (for planning) */
  estimatedTokensPerSubAgent?: number;
  /** Whether to log token usage warnings */
  enableTokenWarnings?: boolean;
  
  // === External Agent Delegation ===
  // Support for delegating tasks to external agents (ACP, A2A, etc.)
  
  /** Enable external agent delegation */
  enableExternalAgents?: boolean;
  /** Preferred external agent ID (always delegate to this agent if available) */
  preferredExternalAgentId?: string;
  /** Use external agent as fallback when local execution fails */
  externalAgentFallback?: boolean;
  /** Delegation rules for routing tasks to external agents */
  delegationRules?: ExternalAgentDelegationRule[];
  /** Callback when delegating to external agent */
  onExternalAgentDelegation?: (agentId: string, task: string) => void;
}

/**
 * Result of smart routing analysis
 */
export interface SmartRoutingResult {
  /** Whether to use multi-agent */
  useMultiAgent: boolean;
  /** Reasoning for the decision */
  reason: string;
  /** Confidence score (0-1) */
  confidence: number;
  /** Estimated token usage for single agent approach */
  estimatedSingleAgentTokens?: number;
  /** Factors that influenced the decision */
  factors: {
    taskComplexity: 'simple' | 'moderate' | 'complex';
    parallelizationBenefit: boolean;
    contextIsolationNeeded: boolean;
    toolSpecializationNeeded: boolean;
  };
}

/**
 * Orchestrator execution options
 */
export interface OrchestratorExecutionOptions {
  onStart?: () => void;
  onPlanGenerated?: (plan: SubAgentPlan) => void;
  onSubAgentCreate?: (subAgent: SubAgent) => void;
  onSubAgentStart?: (subAgent: SubAgent) => void;
  onSubAgentComplete?: (subAgent: SubAgent, result: SubAgentResult) => void;
  onSubAgentError?: (subAgent: SubAgent, error: string) => void;
  onProgress?: (progress: OrchestratorProgress) => void;
  onComplete?: (result: OrchestratorResult) => void;
  onError?: (error: string) => void;
  onToolCall?: (toolCall: ToolCall) => void;
  onToolResult?: (toolCall: ToolCall) => void;
  traceContext?: ExternalAgentExecutionOptions['traceContext'];
}

/**
 * Sub-agent plan generated by the orchestrator
 */
export interface SubAgentPlan {
  id: string;
  task: string;
  subAgents: Array<{
    name: string;
    description: string;
    task: string;
    dependencies?: string[];
    priority?: 'critical' | 'high' | 'normal' | 'low' | 'background';
  }>;
  executionMode: SubAgentExecutionMode;
  reasoning: string;
}

/**
 * Orchestrator progress information
 */
export interface OrchestratorProgress {
  phase: 'planning' | 'executing' | 'aggregating' | 'completed';
  totalSubAgents: number;
  completedSubAgents: number;
  runningSubAgents: number;
  failedSubAgents: number;
  progress: number;
  currentActivity?: string;
}

/**
 * Orchestrator execution result
 */
export interface OrchestratorResult {
  success: boolean;
  finalResponse: string;
  plan?: SubAgentPlan;
  subAgentResults: SubAgentOrchestrationResult;
  parentAgentResult?: AgentResult;
  totalDuration: number;
  tokenUsage?: {
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
  };
  error?: string;
}

/**
 * Planning prompt for generating sub-agent tasks
 */
const PLANNING_PROMPT = `You are a task orchestration expert. Analyze the given task and break it down into sub-tasks that can be executed by specialized sub-agents.

For each sub-task, provide:
1. A clear, descriptive name
2. A brief description of what the sub-agent should accomplish
3. The specific task/prompt for the sub-agent
4. Any dependencies on other sub-tasks (by name)
5. Priority level (critical, high, normal, low, background)

Consider:
- Which tasks can be done in parallel vs. sequentially
- Dependencies between tasks
- The optimal order of execution
- How results from one task might inform another

Output your plan in the following JSON format:
{
  "executionMode": "parallel" | "sequential" | "conditional",
  "reasoning": "Brief explanation of your planning decisions",
  "subAgents": [
    {
      "name": "SubAgent Name",
      "description": "What this sub-agent does",
      "task": "Specific task prompt",
      "dependencies": ["Other SubAgent Name"],
      "priority": "normal"
    }
  ]
}

Task to break down:
`;

/**
 * Token budget-aware planning prompt extension
 */
const TOKEN_BUDGET_PROMPT_EXTENSION = `

IMPORTANT - Token Budget Constraints:
- Maximum sub-agents allowed: {{maxSubAgents}}
- Estimated token budget per sub-agent: ~{{tokensPerAgent}} tokens
- Total budget: ~{{totalBudget}} tokens

Keep the plan efficient - prefer fewer, well-scoped sub-agents over many small ones.
Each additional sub-agent adds significant overhead (system prompts, context, aggregation).
`;

/**
 * Aggregation prompt for combining sub-agent results
 */
const AGGREGATION_PROMPT = `You are a result aggregation expert. Combine the following sub-agent results into a coherent, comprehensive response.

Original Task: {{task}}

Sub-Agent Results:
{{results}}

Provide a unified response that:
1. Synthesizes all the information from sub-agents
2. Resolves any conflicts or inconsistencies
3. Presents the information in a clear, organized manner
4. Addresses the original task completely
`;

/**
 * Agent Orchestrator class
 */
/**
 * Orchestrator state for pause/resume
 */
export interface OrchestratorState {
  phase: 'idle' | 'planning' | 'executing' | 'aggregating' | 'completed' | 'paused' | 'cancelled';
  task: string;
  plan?: SubAgentPlan;
  completedSubAgentIds: string[];
  pendingSubAgentIds: string[];
  partialResults: Record<string, SubAgentResult>;
  startTime: number;
  pausedAt?: number;
  totalPausedDuration: number;
}

export class AgentOrchestrator {
  private config: OrchestratorConfig;
  private subAgents: Map<string, SubAgent> = new Map();
  private isRunning: boolean = false;
  private isCancelled: boolean = false;
  private isPaused: boolean = false;
  private pauseResolve: (() => void) | null = null;
  private state: OrchestratorState = {
    phase: 'idle',
    task: '',
    completedSubAgentIds: [],
    pendingSubAgentIds: [],
    partialResults: {},
    startTime: 0,
    totalPausedDuration: 0,
  };

  constructor(config: OrchestratorConfig) {
    this.config = {
      maxSubAgents: 10,
      maxConcurrentSubAgents: 3,
      enableAutoPlanning: true,
      enableDynamicSubAgents: true,
      // Smart routing defaults
      enableSmartRouting: false, // Opt-in for backward compatibility
      singleAgentThreshold: 0.6,
      contextIsolationThreshold: 50000, // ~50k tokens
      ...config,
    };
  }

  /**
   * Analyze task to decide if multi-agent is beneficial
   * Based on Claude's Multi-Agent Decision Framework:
   * 1. Context Pollution - Does task generate high-volume irrelevant info?
   * 2. Parallelization - Can independent facets be explored simultaneously?
   * 3. Specialization - Do different subtasks need different tool sets?
   */
  async analyzeForSmartRouting(task: string): Promise<SmartRoutingResult> {
    const toolCount = Object.keys(this.config.tools || {}).length;
    
    // Quick heuristic analysis (no LLM call for efficiency)
    const factors = {
      taskComplexity: this.assessTaskComplexity(task),
      parallelizationBenefit: this.hasParallelizationPotential(task),
      contextIsolationNeeded: this.needsContextIsolation(task, toolCount),
      toolSpecializationNeeded: toolCount > 15, // Claude recommends < 20 tools per agent
    };
    
    // Calculate score
    let multiAgentScore = 0;
    
    // Complex tasks benefit from decomposition
    if (factors.taskComplexity === 'complex') multiAgentScore += 0.4;
    else if (factors.taskComplexity === 'moderate') multiAgentScore += 0.2;
    
    // Parallelization provides throughput benefits
    if (factors.parallelizationBenefit) multiAgentScore += 0.25;
    
    // Context isolation prevents pollution
    if (factors.contextIsolationNeeded) multiAgentScore += 0.25;
    
    // Tool specialization improves selection accuracy
    if (factors.toolSpecializationNeeded) multiAgentScore += 0.2;
    
    const threshold = this.config.singleAgentThreshold ?? 0.6;
    const useMultiAgent = multiAgentScore >= (1 - threshold);
    
    // Build reasoning
    const reasons: string[] = [];
    if (factors.taskComplexity === 'complex') {
      reasons.push('Task is complex and benefits from decomposition');
    }
    if (factors.parallelizationBenefit) {
      reasons.push('Independent subtasks can be parallelized');
    }
    if (factors.contextIsolationNeeded) {
      reasons.push('Context isolation prevents information pollution');
    }
    if (factors.toolSpecializationNeeded) {
      reasons.push(`High tool count (${toolCount}) benefits from specialization`);
    }
    
    if (!useMultiAgent) {
      reasons.unshift('Single agent is more efficient for this task');
    }
    
    return {
      useMultiAgent,
      reason: reasons.join('; ') || 'Simple task suitable for single agent',
      confidence: Math.abs(multiAgentScore - 0.5) * 2, // 0-1 scale, higher when decision is clear
      factors,
    };
  }

  /**
   * Assess task complexity based on text analysis
   */
  private assessTaskComplexity(task: string): 'simple' | 'moderate' | 'complex' {
    const wordCount = task.split(/\s+/).length;
    const hasMultipleSteps = /\b(and then|after that|next|finally|first|second|third)\b/i.test(task);
    const hasMultipleDomains = /\b(research|analyze|create|compare|summarize|implement)\b/gi.test(task);
    const matchCount = (task.match(/\b(research|analyze|create|compare|summarize|implement|search|find|build|write|review)\b/gi) || []).length;
    
    if (wordCount > 100 || (hasMultipleSteps && matchCount >= 3)) {
      return 'complex';
    }
    if (wordCount > 40 || hasMultipleDomains || matchCount >= 2) {
      return 'moderate';
    }
    return 'simple';
  }

  /**
   * Check if task has parallelization potential
   */
  private hasParallelizationPotential(task: string): boolean {
    // Look for patterns suggesting independent parallel work
    const parallelPatterns = [
      /\b(multiple|several|various|different)\s+(sources|options|approaches|methods)\b/i,
      /\b(compare|contrast)\b.*\b(and|with|versus)\b/i,
      /\b(search|find|research)\b.*\b(across|from multiple)\b/i,
      /\b(simultaneously|in parallel|at the same time)\b/i,
    ];
    
    return parallelPatterns.some(pattern => pattern.test(task));
  }

  /**
   * Check if task needs context isolation
   */
  private needsContextIsolation(task: string, toolCount: number): boolean {
    // Tasks involving data retrieval often generate high-volume context
    const dataIntensivePatterns = [
      /\b(database|api|fetch|retrieve|query|search)\b.*\b(data|records|results)\b/i,
      /\b(analyze|process)\b.*\b(large|extensive|comprehensive)\b/i,
      /\b(history|logs|records)\b/i,
    ];
    
    const isDataIntensive = dataIntensivePatterns.some(pattern => pattern.test(task));
    const hasManyTools = toolCount > 10;
    
    return isDataIntensive || hasManyTools;
  }

  /**
   * Generate a plan for sub-agents based on the task
   * Includes token budget awareness when configured (Claude Best Practice)
   */
  async generatePlan(task: string): Promise<SubAgentPlan> {
    const modelInstance = getProviderModel(
      this.config.provider,
      this.config.model,
      this.config.apiKey,
      this.config.baseURL
    );

    // Build prompt with optional token budget constraints
    let prompt = PLANNING_PROMPT;
    
    if (this.config.maxTokenBudget || this.config.estimatedTokensPerSubAgent) {
      const tokensPerAgent = this.config.estimatedTokensPerSubAgent ?? 2000;
      const maxBudget = this.config.maxTokenBudget ?? 50000;
      const maxSubAgents = Math.min(
        this.config.maxSubAgents ?? 10,
        Math.floor(maxBudget / tokensPerAgent)
      );
      
      prompt += TOKEN_BUDGET_PROMPT_EXTENSION
        .replace('{{maxSubAgents}}', maxSubAgents.toString())
        .replace('{{tokensPerAgent}}', tokensPerAgent.toString())
        .replace('{{totalBudget}}', maxBudget.toString());
      
      if (this.config.enableTokenWarnings) {
        log.info('Token budget configured', {
          maxBudget,
          maxSubAgents,
          tokensPerAgent,
        });
      }
    }
    
    prompt += task;

    const result = await generateText({
      model: modelInstance,
      prompt,
      temperature: 0.3,
    });

    // Parse the JSON response
    const jsonMatch = result.text.match(/\{[\s\S]*\}/);
    if (!jsonMatch) {
      throw new Error('Failed to parse planning response');
    }

    const parsed = JSON.parse(jsonMatch[0]);
    
    // Validate plan against budget constraints
    let subAgents = parsed.subAgents || [];
    const maxAllowed = this.config.maxSubAgents ?? 10;
    
    if (subAgents.length > maxAllowed) {
      if (this.config.enableTokenWarnings) {
        log.warn('Plan exceeds sub-agent limit, truncating', {
          requested: subAgents.length,
          allowed: maxAllowed,
        });
      }
      // Keep highest priority agents
      subAgents = subAgents
        .sort((a: { priority?: string }, b: { priority?: string }) => {
          const priorityOrder: Record<string, number> = { critical: 0, high: 1, normal: 2, low: 3, background: 4 };
          return (priorityOrder[a.priority || 'normal'] ?? 2) - (priorityOrder[b.priority || 'normal'] ?? 2);
        })
        .slice(0, maxAllowed);
    }
    
    return {
      id: nanoid(),
      task,
      subAgents,
      executionMode: parsed.executionMode || 'sequential',
      reasoning: parsed.reasoning || '',
    };
  }

  /**
   * Create sub-agents from a plan
   */
  createSubAgentsFromPlan(
    plan: SubAgentPlan,
    parentAgentId: string
  ): SubAgent[] {
    const subAgents: SubAgent[] = [];
    const nameToIdMap = new Map<string, string>();

    // First pass: create all sub-agents
    plan.subAgents.forEach((spec, index) => {
      const subAgent = createSubAgent({
        parentAgentId,
        name: spec.name,
        description: spec.description,
        task: spec.task,
        config: {
          ...this.config.defaultSubAgentConfig,
          priority: spec.priority || 'normal',
        },
        order: index,
      });

      nameToIdMap.set(spec.name, subAgent.id);
      subAgents.push(subAgent);
      this.subAgents.set(subAgent.id, subAgent);
    });

    // Second pass: resolve dependencies
    plan.subAgents.forEach((spec, index) => {
      if (spec.dependencies && spec.dependencies.length > 0) {
        const subAgent = subAgents[index];
        subAgent.config.dependencies = spec.dependencies
          .map(depName => nameToIdMap.get(depName))
          .filter((id): id is string => id !== undefined);
      }
    });

    return subAgents;
  }

  /**
   * Execute sub-agents based on the plan
   */
  async executeSubAgents(
    subAgents: SubAgent[],
    executionMode: SubAgentExecutionMode,
    options: OrchestratorExecutionOptions
  ): Promise<SubAgentOrchestrationResult> {
    const executorConfig: SubAgentExecutorConfig = {
      provider: this.config.provider,
      model: this.config.model,
      apiKey: this.config.apiKey,
      baseURL: this.config.baseURL,
      globalTools: this.config.tools,
    };

    const subAgentOptions: SubAgentExecutionOptions = {
      onStart: (subAgent) => {
        options.onSubAgentStart?.(subAgent);
        this.updateProgress(options, 'executing');
      },
      onComplete: (subAgent, result) => {
        options.onSubAgentComplete?.(subAgent, result);
        this.updateProgress(options, 'executing');
      },
      onError: (subAgent, error) => {
        options.onSubAgentError?.(subAgent, error);
        this.updateProgress(options, 'executing');
      },
      onToolCall: (_, toolCall) => options.onToolCall?.(toolCall),
      onToolResult: (_, toolCall) => options.onToolResult?.(toolCall),
    };

    if (executionMode === 'parallel') {
      return executeSubAgentsParallel(
        subAgents,
        executorConfig,
        subAgentOptions,
        this.config.maxConcurrentSubAgents
      );
    } else {
      return executeSubAgentsSequential(
        subAgents,
        executorConfig,
        subAgentOptions,
        true
      );
    }
  }

  /**
   * Aggregate results from sub-agents
   */
  async aggregateResults(
    task: string,
    orchestrationResult: SubAgentOrchestrationResult
  ): Promise<string> {
    const resultsText = Object.entries(orchestrationResult.results)
      .map(([id, result]) => {
        const subAgent = this.subAgents.get(id);
        return `## ${subAgent?.name || id}\n${result.finalResponse}`;
      })
      .join('\n\n');

    const prompt = AGGREGATION_PROMPT
      .replace('{{task}}', task)
      .replace('{{results}}', resultsText);

    const modelInstance = getProviderModel(
      this.config.provider,
      this.config.model,
      this.config.apiKey,
      this.config.baseURL
    );

    const result = await generateText({
      model: modelInstance,
      prompt,
      temperature: 0.5,
    });

    return result.text;
  }

  /**
   * Update progress and notify listeners
   */
  private updateProgress(
    options: OrchestratorExecutionOptions,
    phase: OrchestratorProgress['phase']
  ): void {
    const subAgents = Array.from(this.subAgents.values());
    const completed = subAgents.filter(a => a.status === 'completed').length;
    const running = subAgents.filter(a => a.status === 'running').length;
    const failed = subAgents.filter(a => a.status === 'failed').length;
    const total = subAgents.length;

    const progress: OrchestratorProgress = {
      phase,
      totalSubAgents: total,
      completedSubAgents: completed,
      runningSubAgents: running,
      failedSubAgents: failed,
      progress: total > 0 ? Math.round((completed / total) * 100) : 0,
    };

    options.onProgress?.(progress);
  }

  /**
   * Execute the orchestrated task
   */
  async execute(
    task: string,
    options: OrchestratorExecutionOptions = {}
  ): Promise<OrchestratorResult> {
    const startTime = Date.now();
    this.isRunning = true;
    this.isCancelled = false;
    this.isPaused = false;
    this.subAgents.clear();
    
    // Initialize state
    this.state = {
      phase: 'planning',
      task,
      completedSubAgentIds: [],
      pendingSubAgentIds: [],
      partialResults: {},
      startTime,
      totalPausedDuration: 0,
    };

    options.onStart?.();

    try {
      // External Agent Delegation: Check if task should be delegated
      if (this.config.enableExternalAgents) {
        const delegationResult = this.checkExternalAgentDelegation(task);
        
        if (delegationResult.shouldDelegate && delegationResult.targetAgentId) {
          log.info('Delegating to external agent', {
            agentId: delegationResult.targetAgentId,
            reason: delegationResult.reason,
          });
          
          try {
            return await this.executeOnExternalAgent(
              delegationResult.targetAgentId,
              task,
              options
            );
          } catch (error) {
            // Check if this is a fallback signal
            const errorMsg = error instanceof Error ? error.message : '';
            if (errorMsg.startsWith('EXTERNAL_AGENT_FALLBACK:')) {
              log.info('Falling back to local execution after external agent failure');
              // Continue with local execution below
            } else {
              throw error;
            }
          }
        }
      }

      // Smart Routing: Decide if multi-agent is beneficial (Claude Best Practice)
      let useMultiAgent = this.config.enableAutoPlanning ?? true;
      let routingResult: SmartRoutingResult | undefined;
      
      if (this.config.enableSmartRouting) {
        routingResult = await this.analyzeForSmartRouting(task);
        useMultiAgent = routingResult.useMultiAgent;
        
        log.info('Smart routing decision', {
          useMultiAgent,
          reason: routingResult.reason,
        });
      }

      // Phase 1: Planning
      options.onProgress?.({
        phase: 'planning',
        totalSubAgents: 0,
        completedSubAgents: 0,
        runningSubAgents: 0,
        failedSubAgents: 0,
        progress: 0,
        currentActivity: useMultiAgent ? 'Generating execution plan...' : 'Preparing single agent execution...',
      });

      let plan: SubAgentPlan;
      
      if (useMultiAgent && this.config.enableAutoPlanning) {
        plan = await this.generatePlan(task);
        options.onPlanGenerated?.(plan);
      } else {
        // Create a single sub-agent for the entire task (more token-efficient)
        plan = {
          id: nanoid(),
          task,
          subAgents: [{
            name: 'Main Agent',
            description: 'Execute the main task',
            task,
            priority: 'normal',
          }],
          executionMode: 'sequential',
          reasoning: routingResult?.reason || 'Single agent execution',
        };
      }

      if (this.isCancelled) {
        throw new Error('Execution cancelled');
      }

      // Check for pause
      await this.waitIfPaused();
      if (this.isCancelled) {
        throw new Error('Execution cancelled');
      }

      // Phase 2: Create sub-agents
      this.state.phase = 'executing';
      const parentAgentId = nanoid();
      const subAgents = this.createSubAgentsFromPlan(plan, parentAgentId);
      
      subAgents.forEach(subAgent => {
        options.onSubAgentCreate?.(subAgent);
      });

      // Phase 3: Execute sub-agents
      this.updateProgress(options, 'executing');
      
      const orchestrationResult = await this.executeSubAgents(
        subAgents,
        plan.executionMode,
        options
      );

      if (this.isCancelled) {
        throw new Error('Execution cancelled');
      }

      // Check for pause before aggregation
      await this.waitIfPaused();
      if (this.isCancelled) {
        throw new Error('Execution cancelled');
      }

      // Phase 4: Aggregate results
      this.state.phase = 'aggregating';
      options.onProgress?.({
        phase: 'aggregating',
        totalSubAgents: subAgents.length,
        completedSubAgents: subAgents.filter(a => a.status === 'completed').length,
        runningSubAgents: 0,
        failedSubAgents: subAgents.filter(a => a.status === 'failed').length,
        progress: 90,
        currentActivity: 'Aggregating results...',
      });

      let finalResponse: string;
      
      if (orchestrationResult.success && subAgents.length > 1) {
        finalResponse = await this.aggregateResults(task, orchestrationResult);
      } else if (orchestrationResult.success) {
        finalResponse = orchestrationResult.aggregatedResponse || '';
      } else {
        const errors = Object.entries(orchestrationResult.errors || {})
          .map(([id, error]) => {
            const subAgent = this.subAgents.get(id);
            return `${subAgent?.name || id}: ${error}`;
          })
          .join('\n');
        finalResponse = `Some sub-agents failed:\n${errors}\n\nPartial results:\n${orchestrationResult.aggregatedResponse || 'None'}`;
      }

      // Complete
      const result: OrchestratorResult = {
        success: orchestrationResult.success,
        finalResponse,
        plan,
        subAgentResults: orchestrationResult,
        totalDuration: Date.now() - startTime,
        tokenUsage: orchestrationResult.totalTokenUsage,
      };

      options.onProgress?.({
        phase: 'completed',
        totalSubAgents: subAgents.length,
        completedSubAgents: subAgents.filter(a => a.status === 'completed').length,
        runningSubAgents: 0,
        failedSubAgents: subAgents.filter(a => a.status === 'failed').length,
        progress: 100,
      });

      options.onComplete?.(result);
      this.isRunning = false;

      return result;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Orchestration failed';
      
      options.onError?.(errorMessage);
      this.isRunning = false;

      return {
        success: false,
        finalResponse: '',
        subAgentResults: {
          success: false,
          results: {},
          totalDuration: Date.now() - startTime,
        },
        totalDuration: Date.now() - startTime,
        error: errorMessage,
      };
    }
  }

  /**
   * Cancel the current execution
   */
  cancel(): void {
    this.isCancelled = true;
    this.state.phase = 'cancelled';
    
    // Resume if paused so it can exit
    if (this.isPaused && this.pauseResolve) {
      this.pauseResolve();
      this.pauseResolve = null;
    }
    
    cancelAllSubAgents(Array.from(this.subAgents.values()));
  }

  /**
   * Pause the current execution
   */
  pause(): boolean {
    if (!this.isRunning || this.isPaused || this.isCancelled) {
      return false;
    }

    this.isPaused = true;
    this.state.pausedAt = Date.now();
    this.state.phase = 'paused';
    
    // Store current progress
    this.state.completedSubAgentIds = Array.from(this.subAgents.values())
      .filter(sa => sa.status === 'completed')
      .map(sa => sa.id);
    
    this.state.pendingSubAgentIds = Array.from(this.subAgents.values())
      .filter(sa => sa.status === 'pending' || sa.status === 'running')
      .map(sa => sa.id);
    
    // Store partial results
    Array.from(this.subAgents.values())
      .filter(sa => sa.status === 'completed' && sa.result)
      .forEach(sa => {
        this.state.partialResults[sa.id] = sa.result!;
      });

    return true;
  }

  /**
   * Resume a paused execution
   */
  resume(): boolean {
    if (!this.isPaused) {
      return false;
    }

    this.isPaused = false;
    
    // Calculate paused duration
    if (this.state.pausedAt) {
      this.state.totalPausedDuration += Date.now() - this.state.pausedAt;
      this.state.pausedAt = undefined;
    }

    // Resume execution
    if (this.pauseResolve) {
      this.pauseResolve();
      this.pauseResolve = null;
    }

    return true;
  }

  /**
   * Wait if paused
   */
  private async waitIfPaused(): Promise<void> {
    if (this.isPaused) {
      await new Promise<void>(resolve => {
        this.pauseResolve = resolve;
      });
    }
  }

  /**
   * Get current orchestrator state
   */
  getState(): OrchestratorState {
    return { ...this.state };
  }

  /**
   * Check if orchestrator is paused
   */
  getIsPaused(): boolean {
    return this.isPaused;
  }

  /**
   * Get all sub-agents
   */
  getSubAgents(): SubAgent[] {
    return Array.from(this.subAgents.values());
  }

  /**
   * Get a specific sub-agent
   */
  getSubAgent(id: string): SubAgent | undefined {
    return this.subAgents.get(id);
  }

  /**
   * Check if orchestrator is running
   */
  getIsRunning(): boolean {
    return this.isRunning;
  }

  // ============================================================================
  // External Agent Delegation
  // ============================================================================

  /**
   * Check if a task should be delegated to an external agent
   */
  checkExternalAgentDelegation(task: string): ExternalAgentDelegationResult {
    // If external agents are not enabled, return false
    if (!this.config.enableExternalAgents) {
      return { shouldDelegate: false, reason: 'External agents not enabled' };
    }

    // If a preferred external agent is set, always delegate to it
    if (this.config.preferredExternalAgentId) {
      return {
        shouldDelegate: true,
        targetAgentId: this.config.preferredExternalAgentId,
        reason: 'Preferred external agent configured',
      };
    }

    // Check delegation rules
    const rules = this.config.delegationRules || [];
    for (const rule of rules.sort((a, b) => b.priority - a.priority)) {
      if (!rule.enabled) continue;

      let matched = false;

      switch (rule.condition) {
        case 'always':
          matched = true;
          break;

        case 'keyword':
          matched = new RegExp(rule.matcher, 'i').test(task);
          break;

        case 'task-type':
          matched = this.matchTaskTypeForDelegation(task, rule.matcher);
          break;

        case 'capability':
          // Capability matching requires checking external agent manager
          // For now, just check if the rule matcher is in the task
          matched = task.toLowerCase().includes(rule.matcher.toLowerCase());
          break;

        case 'tool-needed':
          // Check if task mentions tools that might be on external agent
          matched = new RegExp(rule.matcher, 'i').test(task);
          break;

        case 'custom':
          matched = new RegExp(rule.matcher, 'i').test(task);
          break;
      }

      if (matched) {
        return {
          shouldDelegate: true,
          targetAgentId: rule.targetAgentId,
          matchedRule: rule,
          reason: `Matched delegation rule: ${rule.name}`,
        };
      }
    }

    return { shouldDelegate: false, reason: 'No matching delegation rule' };
  }

  /**
   * Match task type for delegation
   */
  private matchTaskTypeForDelegation(task: string, taskType: string): boolean {
    const taskTypePatterns: Record<string, RegExp> = {
      coding: /\b(code|implement|fix|debug|refactor|write.*function|create.*class|build|program)\b/i,
      analysis: /\b(analyze|review|audit|check|examine|investigate|assess)\b/i,
      documentation: /\b(document|write.*readme|add.*comments|explain|describe)\b/i,
      testing: /\b(test|unit test|e2e|coverage|mock|verify)\b/i,
      deployment: /\b(deploy|release|build|publish|ci|cd|pipeline)\b/i,
      research: /\b(research|find|search|lookup|discover|explore)\b/i,
      design: /\b(design|architect|plan|structure|model)\b/i,
    };

    const pattern = taskTypePatterns[taskType.toLowerCase()];
    return pattern ? pattern.test(task) : false;
  }

  /**
   * Execute task on external agent
   * This is called when delegation check passes
   */
  async executeOnExternalAgent(
    agentId: string,
    task: string,
    options: OrchestratorExecutionOptions = {}
  ): Promise<OrchestratorResult> {
    const startTime = Date.now();

    // Notify about delegation
    this.config.onExternalAgentDelegation?.(agentId, task);

    try {
      // Dynamic import to avoid circular dependencies
      const { getExternalAgentManager } = await import('./external/manager');
      const manager = getExternalAgentManager();

      // Check if agent is connected
      const agent = manager.getAgent(agentId);
      if (!agent) {
        throw new Error(`External agent not found: ${agentId}`);
      }

      if (agent.connectionStatus !== 'connected') {
        // Try to connect
        await manager.connect(agentId);
      }

      // Build execution options
      const inheritedTraceContext = options.traceContext;
      const traceTags = Array.from(new Set(['orchestrator-external-agent', ...(inheritedTraceContext?.tags ?? [])]));
      const execOptions: ExternalAgentExecutionOptions = {
        systemPrompt: this.config.systemPrompt,
        timeout: this.config.maxSteps ? this.config.maxSteps * 30000 : 300000,
        traceContext: {
          ...inheritedTraceContext,
          tags: traceTags,
          metadata: {
            ...(inheritedTraceContext?.metadata ?? {}),
            delegatedBy: 'agent-orchestrator',
          },
        },
        onProgress: (progress, message) => {
          options.onProgress?.({
            phase: 'executing',
            totalSubAgents: 1,
            completedSubAgents: 0,
            runningSubAgents: 1,
            failedSubAgents: 0,
            progress,
            currentActivity: message || `Executing on external agent: ${agent.config.name}`,
          });
        },
      };

      // Execute on external agent
      const result = await manager.execute(agentId, task, execOptions);

      // Convert to OrchestratorResult
      const externalSubAgentResult: SubAgentResult = {
        success: result.success,
        finalResponse: result.finalResponse,
        output: result.output,
        duration: result.duration,
        steps: result.steps.map((step, idx) => ({
          stepNumber: idx + 1,
          response: step.content?.find(c => c.type === 'text')?.text || '',
          toolCalls: step.toolCall ? [{
            id: step.toolCall.id,
            name: step.toolCall.name,
            args: step.toolCall.input,
            status: 'completed' as const,
          }] : [],
          timestamp: step.startedAt || new Date(),
          duration: step.duration,
        })),
        totalSteps: result.steps.length,
        tokenUsage: result.tokenUsage ? {
          promptTokens: result.tokenUsage.promptTokens,
          completionTokens: result.tokenUsage.completionTokens,
          totalTokens: result.tokenUsage.totalTokens,
        } : undefined,
        error: result.error,
      };

      const orchestratorResult: OrchestratorResult = {
        success: result.success,
        finalResponse: result.finalResponse,
        subAgentResults: {
          success: result.success,
          results: {
            external: externalSubAgentResult,
          },
          totalDuration: result.duration,
          totalTokenUsage: result.tokenUsage ? {
            promptTokens: result.tokenUsage.promptTokens,
            completionTokens: result.tokenUsage.completionTokens,
            totalTokens: result.tokenUsage.totalTokens,
          } : undefined,
        },
        totalDuration: Date.now() - startTime,
        tokenUsage: result.tokenUsage,
        error: result.error,
      };

      options.onComplete?.(orchestratorResult);
      return orchestratorResult;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);

      // If fallback is enabled, return null to indicate local execution should be tried
      if (this.config.externalAgentFallback) {
        log.warn('External agent execution failed, falling back to local', { error: errorMessage });
        throw new Error(`EXTERNAL_AGENT_FALLBACK:${errorMessage}`);
      }

      const failedResult: OrchestratorResult = {
        success: false,
        finalResponse: '',
        subAgentResults: {
          success: false,
          results: {},
          totalDuration: Date.now() - startTime,
          errors: { external: errorMessage },
        },
        totalDuration: Date.now() - startTime,
        error: `External agent execution failed: ${errorMessage}`,
      };

      options.onError?.(errorMessage);
      return failedResult;
    }
  }
}

/**
 * Create an orchestrator instance
 */
export function createOrchestrator(config: OrchestratorConfig): AgentOrchestrator {
  return new AgentOrchestrator(config);
}

/**
 * Execute a task with automatic orchestration
 */
export async function executeOrchestrated(
  task: string,
  config: OrchestratorConfig,
  options: OrchestratorExecutionOptions = {}
): Promise<OrchestratorResult> {
  const orchestrator = new AgentOrchestrator(config);
  return orchestrator.execute(task, options);
}
