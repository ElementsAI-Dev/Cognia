/**
 * Agent Orchestrator - Coordinate parent agents and their sub-agents
 * 
 * Features:
 * - Manage agent hierarchies (parent -> sub-agents)
 * - Coordinate parallel and sequential execution
 * - Handle result aggregation and context sharing
 * - Support for dynamic sub-agent creation during execution
 */

import { nanoid } from 'nanoid';
import { generateText } from 'ai';
import { getProviderModel, type ProviderName } from '../core/client';
import { type AgentResult, type AgentTool, type ToolCall } from './agent-executor';
import {
  createSubAgent,
  executeSubAgentsParallel,
  executeSubAgentsSequential,
  cancelAllSubAgents,
  type SubAgentExecutorConfig,
} from './sub-agent-executor';
import type {
  SubAgent,
  SubAgentConfig,
  SubAgentResult,
  SubAgentExecutionOptions,
  SubAgentOrchestrationResult,
  SubAgentExecutionMode,
} from '@/types/sub-agent';

/**
 * Orchestrator configuration
 */
export interface OrchestratorConfig {
  provider: ProviderName;
  model: string;
  apiKey: string;
  baseURL?: string;
  systemPrompt?: string;
  temperature?: number;
  maxSteps?: number;
  maxSubAgents?: number;
  maxConcurrentSubAgents?: number;
  defaultSubAgentConfig?: Partial<SubAgentConfig>;
  tools?: Record<string, AgentTool>;
  enableAutoPlanning?: boolean;
  enableDynamicSubAgents?: boolean;
}

/**
 * Orchestrator execution options
 */
export interface OrchestratorExecutionOptions {
  onStart?: () => void;
  onPlanGenerated?: (plan: SubAgentPlan) => void;
  onSubAgentCreate?: (subAgent: SubAgent) => void;
  onSubAgentStart?: (subAgent: SubAgent) => void;
  onSubAgentComplete?: (subAgent: SubAgent, result: SubAgentResult) => void;
  onSubAgentError?: (subAgent: SubAgent, error: string) => void;
  onProgress?: (progress: OrchestratorProgress) => void;
  onComplete?: (result: OrchestratorResult) => void;
  onError?: (error: string) => void;
  onToolCall?: (toolCall: ToolCall) => void;
  onToolResult?: (toolCall: ToolCall) => void;
}

/**
 * Sub-agent plan generated by the orchestrator
 */
export interface SubAgentPlan {
  id: string;
  task: string;
  subAgents: Array<{
    name: string;
    description: string;
    task: string;
    dependencies?: string[];
    priority?: 'critical' | 'high' | 'normal' | 'low' | 'background';
  }>;
  executionMode: SubAgentExecutionMode;
  reasoning: string;
}

/**
 * Orchestrator progress information
 */
export interface OrchestratorProgress {
  phase: 'planning' | 'executing' | 'aggregating' | 'completed';
  totalSubAgents: number;
  completedSubAgents: number;
  runningSubAgents: number;
  failedSubAgents: number;
  progress: number;
  currentActivity?: string;
}

/**
 * Orchestrator execution result
 */
export interface OrchestratorResult {
  success: boolean;
  finalResponse: string;
  plan?: SubAgentPlan;
  subAgentResults: SubAgentOrchestrationResult;
  parentAgentResult?: AgentResult;
  totalDuration: number;
  tokenUsage?: {
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
  };
  error?: string;
}

/**
 * Planning prompt for generating sub-agent tasks
 */
const PLANNING_PROMPT = `You are a task orchestration expert. Analyze the given task and break it down into sub-tasks that can be executed by specialized sub-agents.

For each sub-task, provide:
1. A clear, descriptive name
2. A brief description of what the sub-agent should accomplish
3. The specific task/prompt for the sub-agent
4. Any dependencies on other sub-tasks (by name)
5. Priority level (critical, high, normal, low, background)

Consider:
- Which tasks can be done in parallel vs. sequentially
- Dependencies between tasks
- The optimal order of execution
- How results from one task might inform another

Output your plan in the following JSON format:
{
  "executionMode": "parallel" | "sequential" | "conditional",
  "reasoning": "Brief explanation of your planning decisions",
  "subAgents": [
    {
      "name": "SubAgent Name",
      "description": "What this sub-agent does",
      "task": "Specific task prompt",
      "dependencies": ["Other SubAgent Name"],
      "priority": "normal"
    }
  ]
}

Task to break down:
`;

/**
 * Aggregation prompt for combining sub-agent results
 */
const AGGREGATION_PROMPT = `You are a result aggregation expert. Combine the following sub-agent results into a coherent, comprehensive response.

Original Task: {{task}}

Sub-Agent Results:
{{results}}

Provide a unified response that:
1. Synthesizes all the information from sub-agents
2. Resolves any conflicts or inconsistencies
3. Presents the information in a clear, organized manner
4. Addresses the original task completely
`;

/**
 * Agent Orchestrator class
 */
/**
 * Orchestrator state for pause/resume
 */
export interface OrchestratorState {
  phase: 'idle' | 'planning' | 'executing' | 'aggregating' | 'completed' | 'paused' | 'cancelled';
  task: string;
  plan?: SubAgentPlan;
  completedSubAgentIds: string[];
  pendingSubAgentIds: string[];
  partialResults: Record<string, SubAgentResult>;
  startTime: number;
  pausedAt?: number;
  totalPausedDuration: number;
}

export class AgentOrchestrator {
  private config: OrchestratorConfig;
  private subAgents: Map<string, SubAgent> = new Map();
  private isRunning: boolean = false;
  private isCancelled: boolean = false;
  private isPaused: boolean = false;
  private pauseResolve: (() => void) | null = null;
  private state: OrchestratorState = {
    phase: 'idle',
    task: '',
    completedSubAgentIds: [],
    pendingSubAgentIds: [],
    partialResults: {},
    startTime: 0,
    totalPausedDuration: 0,
  };

  constructor(config: OrchestratorConfig) {
    this.config = {
      maxSubAgents: 10,
      maxConcurrentSubAgents: 3,
      enableAutoPlanning: true,
      enableDynamicSubAgents: true,
      ...config,
    };
  }

  /**
   * Generate a plan for sub-agents based on the task
   */
  async generatePlan(task: string): Promise<SubAgentPlan> {
    const modelInstance = getProviderModel(
      this.config.provider,
      this.config.model,
      this.config.apiKey,
      this.config.baseURL
    );

    const result = await generateText({
      model: modelInstance,
      prompt: PLANNING_PROMPT + task,
      temperature: 0.3,
    });

    // Parse the JSON response
    const jsonMatch = result.text.match(/\{[\s\S]*\}/);
    if (!jsonMatch) {
      throw new Error('Failed to parse planning response');
    }

    const parsed = JSON.parse(jsonMatch[0]);
    
    return {
      id: nanoid(),
      task,
      subAgents: parsed.subAgents || [],
      executionMode: parsed.executionMode || 'sequential',
      reasoning: parsed.reasoning || '',
    };
  }

  /**
   * Create sub-agents from a plan
   */
  createSubAgentsFromPlan(
    plan: SubAgentPlan,
    parentAgentId: string
  ): SubAgent[] {
    const subAgents: SubAgent[] = [];
    const nameToIdMap = new Map<string, string>();

    // First pass: create all sub-agents
    plan.subAgents.forEach((spec, index) => {
      const subAgent = createSubAgent({
        parentAgentId,
        name: spec.name,
        description: spec.description,
        task: spec.task,
        config: {
          ...this.config.defaultSubAgentConfig,
          priority: spec.priority || 'normal',
        },
        order: index,
      });

      nameToIdMap.set(spec.name, subAgent.id);
      subAgents.push(subAgent);
      this.subAgents.set(subAgent.id, subAgent);
    });

    // Second pass: resolve dependencies
    plan.subAgents.forEach((spec, index) => {
      if (spec.dependencies && spec.dependencies.length > 0) {
        const subAgent = subAgents[index];
        subAgent.config.dependencies = spec.dependencies
          .map(depName => nameToIdMap.get(depName))
          .filter((id): id is string => id !== undefined);
      }
    });

    return subAgents;
  }

  /**
   * Execute sub-agents based on the plan
   */
  async executeSubAgents(
    subAgents: SubAgent[],
    executionMode: SubAgentExecutionMode,
    options: OrchestratorExecutionOptions
  ): Promise<SubAgentOrchestrationResult> {
    const executorConfig: SubAgentExecutorConfig = {
      provider: this.config.provider,
      model: this.config.model,
      apiKey: this.config.apiKey,
      baseURL: this.config.baseURL,
      globalTools: this.config.tools,
    };

    const subAgentOptions: SubAgentExecutionOptions = {
      onStart: (subAgent) => {
        options.onSubAgentStart?.(subAgent);
        this.updateProgress(options, 'executing');
      },
      onComplete: (subAgent, result) => {
        options.onSubAgentComplete?.(subAgent, result);
        this.updateProgress(options, 'executing');
      },
      onError: (subAgent, error) => {
        options.onSubAgentError?.(subAgent, error);
        this.updateProgress(options, 'executing');
      },
      onToolCall: (_, toolCall) => options.onToolCall?.(toolCall),
      onToolResult: (_, toolCall) => options.onToolResult?.(toolCall),
    };

    if (executionMode === 'parallel') {
      return executeSubAgentsParallel(
        subAgents,
        executorConfig,
        subAgentOptions,
        this.config.maxConcurrentSubAgents
      );
    } else {
      return executeSubAgentsSequential(
        subAgents,
        executorConfig,
        subAgentOptions,
        true
      );
    }
  }

  /**
   * Aggregate results from sub-agents
   */
  async aggregateResults(
    task: string,
    orchestrationResult: SubAgentOrchestrationResult
  ): Promise<string> {
    const resultsText = Object.entries(orchestrationResult.results)
      .map(([id, result]) => {
        const subAgent = this.subAgents.get(id);
        return `## ${subAgent?.name || id}\n${result.finalResponse}`;
      })
      .join('\n\n');

    const prompt = AGGREGATION_PROMPT
      .replace('{{task}}', task)
      .replace('{{results}}', resultsText);

    const modelInstance = getProviderModel(
      this.config.provider,
      this.config.model,
      this.config.apiKey,
      this.config.baseURL
    );

    const result = await generateText({
      model: modelInstance,
      prompt,
      temperature: 0.5,
    });

    return result.text;
  }

  /**
   * Update progress and notify listeners
   */
  private updateProgress(
    options: OrchestratorExecutionOptions,
    phase: OrchestratorProgress['phase']
  ): void {
    const subAgents = Array.from(this.subAgents.values());
    const completed = subAgents.filter(a => a.status === 'completed').length;
    const running = subAgents.filter(a => a.status === 'running').length;
    const failed = subAgents.filter(a => a.status === 'failed').length;
    const total = subAgents.length;

    const progress: OrchestratorProgress = {
      phase,
      totalSubAgents: total,
      completedSubAgents: completed,
      runningSubAgents: running,
      failedSubAgents: failed,
      progress: total > 0 ? Math.round((completed / total) * 100) : 0,
    };

    options.onProgress?.(progress);
  }

  /**
   * Execute the orchestrated task
   */
  async execute(
    task: string,
    options: OrchestratorExecutionOptions = {}
  ): Promise<OrchestratorResult> {
    const startTime = Date.now();
    this.isRunning = true;
    this.isCancelled = false;
    this.isPaused = false;
    this.subAgents.clear();
    
    // Initialize state
    this.state = {
      phase: 'planning',
      task,
      completedSubAgentIds: [],
      pendingSubAgentIds: [],
      partialResults: {},
      startTime,
      totalPausedDuration: 0,
    };

    options.onStart?.();

    try {
      // Phase 1: Planning
      options.onProgress?.({
        phase: 'planning',
        totalSubAgents: 0,
        completedSubAgents: 0,
        runningSubAgents: 0,
        failedSubAgents: 0,
        progress: 0,
        currentActivity: 'Generating execution plan...',
      });

      let plan: SubAgentPlan;
      
      if (this.config.enableAutoPlanning) {
        plan = await this.generatePlan(task);
        options.onPlanGenerated?.(plan);
      } else {
        // Create a single sub-agent for the entire task
        plan = {
          id: nanoid(),
          task,
          subAgents: [{
            name: 'Main Agent',
            description: 'Execute the main task',
            task,
            priority: 'normal',
          }],
          executionMode: 'sequential',
          reasoning: 'Single agent execution',
        };
      }

      if (this.isCancelled) {
        throw new Error('Execution cancelled');
      }

      // Check for pause
      await this.waitIfPaused();
      if (this.isCancelled) {
        throw new Error('Execution cancelled');
      }

      // Phase 2: Create sub-agents
      this.state.phase = 'executing';
      const parentAgentId = nanoid();
      const subAgents = this.createSubAgentsFromPlan(plan, parentAgentId);
      
      subAgents.forEach(subAgent => {
        options.onSubAgentCreate?.(subAgent);
      });

      // Phase 3: Execute sub-agents
      this.updateProgress(options, 'executing');
      
      const orchestrationResult = await this.executeSubAgents(
        subAgents,
        plan.executionMode,
        options
      );

      if (this.isCancelled) {
        throw new Error('Execution cancelled');
      }

      // Check for pause before aggregation
      await this.waitIfPaused();
      if (this.isCancelled) {
        throw new Error('Execution cancelled');
      }

      // Phase 4: Aggregate results
      this.state.phase = 'aggregating';
      options.onProgress?.({
        phase: 'aggregating',
        totalSubAgents: subAgents.length,
        completedSubAgents: subAgents.filter(a => a.status === 'completed').length,
        runningSubAgents: 0,
        failedSubAgents: subAgents.filter(a => a.status === 'failed').length,
        progress: 90,
        currentActivity: 'Aggregating results...',
      });

      let finalResponse: string;
      
      if (orchestrationResult.success && subAgents.length > 1) {
        finalResponse = await this.aggregateResults(task, orchestrationResult);
      } else if (orchestrationResult.success) {
        finalResponse = orchestrationResult.aggregatedResponse || '';
      } else {
        const errors = Object.entries(orchestrationResult.errors || {})
          .map(([id, error]) => {
            const subAgent = this.subAgents.get(id);
            return `${subAgent?.name || id}: ${error}`;
          })
          .join('\n');
        finalResponse = `Some sub-agents failed:\n${errors}\n\nPartial results:\n${orchestrationResult.aggregatedResponse || 'None'}`;
      }

      // Complete
      const result: OrchestratorResult = {
        success: orchestrationResult.success,
        finalResponse,
        plan,
        subAgentResults: orchestrationResult,
        totalDuration: Date.now() - startTime,
        tokenUsage: orchestrationResult.totalTokenUsage,
      };

      options.onProgress?.({
        phase: 'completed',
        totalSubAgents: subAgents.length,
        completedSubAgents: subAgents.filter(a => a.status === 'completed').length,
        runningSubAgents: 0,
        failedSubAgents: subAgents.filter(a => a.status === 'failed').length,
        progress: 100,
      });

      options.onComplete?.(result);
      this.isRunning = false;

      return result;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Orchestration failed';
      
      options.onError?.(errorMessage);
      this.isRunning = false;

      return {
        success: false,
        finalResponse: '',
        subAgentResults: {
          success: false,
          results: {},
          totalDuration: Date.now() - startTime,
        },
        totalDuration: Date.now() - startTime,
        error: errorMessage,
      };
    }
  }

  /**
   * Cancel the current execution
   */
  cancel(): void {
    this.isCancelled = true;
    this.state.phase = 'cancelled';
    
    // Resume if paused so it can exit
    if (this.isPaused && this.pauseResolve) {
      this.pauseResolve();
      this.pauseResolve = null;
    }
    
    cancelAllSubAgents(Array.from(this.subAgents.values()));
  }

  /**
   * Pause the current execution
   */
  pause(): boolean {
    if (!this.isRunning || this.isPaused || this.isCancelled) {
      return false;
    }

    this.isPaused = true;
    this.state.pausedAt = Date.now();
    this.state.phase = 'paused';
    
    // Store current progress
    this.state.completedSubAgentIds = Array.from(this.subAgents.values())
      .filter(sa => sa.status === 'completed')
      .map(sa => sa.id);
    
    this.state.pendingSubAgentIds = Array.from(this.subAgents.values())
      .filter(sa => sa.status === 'pending' || sa.status === 'running')
      .map(sa => sa.id);
    
    // Store partial results
    Array.from(this.subAgents.values())
      .filter(sa => sa.status === 'completed' && sa.result)
      .forEach(sa => {
        this.state.partialResults[sa.id] = sa.result!;
      });

    return true;
  }

  /**
   * Resume a paused execution
   */
  resume(): boolean {
    if (!this.isPaused) {
      return false;
    }

    this.isPaused = false;
    
    // Calculate paused duration
    if (this.state.pausedAt) {
      this.state.totalPausedDuration += Date.now() - this.state.pausedAt;
      this.state.pausedAt = undefined;
    }

    // Resume execution
    if (this.pauseResolve) {
      this.pauseResolve();
      this.pauseResolve = null;
    }

    return true;
  }

  /**
   * Wait if paused
   */
  private async waitIfPaused(): Promise<void> {
    if (this.isPaused) {
      await new Promise<void>(resolve => {
        this.pauseResolve = resolve;
      });
    }
  }

  /**
   * Get current orchestrator state
   */
  getState(): OrchestratorState {
    return { ...this.state };
  }

  /**
   * Check if orchestrator is paused
   */
  getIsPaused(): boolean {
    return this.isPaused;
  }

  /**
   * Get all sub-agents
   */
  getSubAgents(): SubAgent[] {
    return Array.from(this.subAgents.values());
  }

  /**
   * Get a specific sub-agent
   */
  getSubAgent(id: string): SubAgent | undefined {
    return this.subAgents.get(id);
  }

  /**
   * Check if orchestrator is running
   */
  getIsRunning(): boolean {
    return this.isRunning;
  }
}

/**
 * Create an orchestrator instance
 */
export function createOrchestrator(config: OrchestratorConfig): AgentOrchestrator {
  return new AgentOrchestrator(config);
}

/**
 * Execute a task with automatic orchestration
 */
export async function executeOrchestrated(
  task: string,
  config: OrchestratorConfig,
  options: OrchestratorExecutionOptions = {}
): Promise<OrchestratorResult> {
  const orchestrator = new AgentOrchestrator(config);
  return orchestrator.execute(task, options);
}
