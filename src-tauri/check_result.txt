cargo :     Blocking waiting for file lock on build directory
At line:1 char:1
+ cargo check 2>&1 | Out-File -FilePath check_result.txt -Encoding utf8 ...
+ ~~~~~~~~~~~~~~~~
    + CategoryInfo          : NotSpecified: (    Blocking wa...build directory:String) [], RemoteException
    + FullyQualifiedErrorId : NativeCommandError
 
    Checking app v0.1.0 (D:\Project\Cognia\src-tauri)
error[E0433]: failed to resolve: use of unresolved module or unlinked crate `once_cell`
 --> src\http.rs:8:5
  |
8 | use once_cell::sync::Lazy;
  |     ^^^^^^^^^ use of unresolved module or unlinked crate `once_cell`
  |
  = help: if you wanted to use a crate named `once_cell`, use `cargo add once_cell` to add it to your `Cargo.toml`

error[E0432]: unresolved import `reqwest`
 --> src\http.rs:9:5
  |
9 | use reqwest::Client;
  |     ^^^^^^^ use of unresolved module or unlinked crate `reqwest`
  |
  = help: if you wanted to use a crate named `reqwest`, use `cargo add reqwest` to add it to your `Cargo.toml`

error[E0432]: unresolved import `parking_lot`
 --> src\screen_recording\recorder.rs:9:5
  |
9 | use parking_lot::RwLock;
  |     ^^^^^^^^^^^ use of unresolved module or unlinked crate `parking_lot`
  |
  = help: if you wanted to use a crate named `parking_lot`, use `cargo add parking_lot` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `base64`
  --> src\screenshot\capture.rs:28:9
   |
28 |     use base64::{engine::general_purpose::STANDARD, Engine};
   |         ^^^^^^ use of unresolved module or unlinked crate `base64`
   |
   = help: if you wanted to use a crate named `base64`, use `cargo add base64` to add it to your `Cargo.toml`

error[E0432]: unresolved import `uuid`
  --> src\screen_recording\recorder.rs:13:5
   |
13 | use uuid::Uuid;
   |     ^^^^ use of unresolved module or unlinked crate `uuid`
   |
   = help: if you wanted to use a crate named `uuid`, use `cargo add uuid` to add it to your `Cargo.toml`

error[E0432]: unresolved import `base64`
  --> src\screenshot\capture.rs:28:9
   |
28 |     use base64::{engine::general_purpose::STANDARD, Engine};
   |         ^^^^^^ use of unresolved module or unlinked crate `base64`
   |
   = help: if you wanted to use a crate named `base64`, use `cargo add base64` to add it to your `Cargo.toml`

error[E0432]: unresolved import `parking_lot`
 --> src\selection\detector.rs:7:5
  |
7 | use parking_lot::RwLock;
  |     ^^^^^^^^^^^ use of unresolved module or unlinked crate `parking_lot`
  |
  = help: if you wanted to use a crate named `parking_lot`, use `cargo add parking_lot` to add it to your `Cargo.toml`

error[E0432]: unresolved import `arboard`
   --> src\selection\detector.rs:199:13
    |
199 |         use arboard::Clipboard;
    |             ^^^^^^^ use of unresolved module or unlinked crate `arboard`
    |
    = help: if you wanted to use a crate named `arboard`, use `cargo add arboard` to add it to your `Cargo.toml`

error[E0432]: unresolved import `rdev`
   --> src\selection\detector.rs:208:17
    |
208 |             use rdev::{simulate, EventType, Key};
    |                 ^^^^ use of unresolved module or unlinked crate `rdev`
    |
    = help: if you wanted to use a crate named `rdev`, use `cargo add rdev` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio_util`
  --> src\selection\toolbar_window.rs:12:5
   |
12 | use tokio_util::sync::CancellationToken;
   |     ^^^^^^^^^^ use of unresolved module or unlinked crate `tokio_util`
   |
   = help: if you wanted to use a crate named `tokio_util`, use `cargo add tokio_util` to add it to your `Cargo.toml`

error[E0432]: unresolved import `parking_lot`
 --> src\selection\toolbar_window.rs:7:5
  |
7 | use parking_lot::RwLock;
  |     ^^^^^^^^^^^ use of unresolved module or unlinked crate `parking_lot`
  |
  = help: if you wanted to use a crate named `parking_lot`, use `cargo add parking_lot` to add it to your `Cargo.toml`

error[E0432]: unresolved import `tauri_plugin_autostart`
  --> src\lib.rs:28:5
   |
28 | use tauri_plugin_autostart;
   |     ^^^^^^^^^^^^^^^^^^^^^^ no external crate `tauri_plugin_autostart`

error[E0432]: unresolved import `parking_lot`
  --> src\awareness\focus_tracker.rs:10:5
   |
10 | use parking_lot::RwLock;
   |     ^^^^^^^^^^^ use of unresolved module or unlinked crate `parking_lot`
   |
   = help: if you wanted to use a crate named `parking_lot`, use `cargo add parking_lot` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `base64`
 --> src\commands\clipboard.rs:3:5
  |
3 | use base64::{engine::general_purpose::STANDARD, Engine};
  |     ^^^^^^ use of unresolved module or unlinked crate `base64`
  |
  = help: if you wanted to use a crate named `base64`, use `cargo add base64` to add it to your `Cargo.toml`

error[E0432]: unresolved import `parking_lot`
  --> src\awareness\mod.rs:26:5
   |
26 | use parking_lot::RwLock;
   |     ^^^^^^^^^^^ use of unresolved module or unlinked crate `parking_lot`
   |
   = help: if you wanted to use a crate named `parking_lot`, use `cargo add parking_lot` to add it to your `Cargo.toml`

error[E0432]: unresolved import `base64`
 --> src\commands\clipboard.rs:3:5
  |
3 | use base64::{engine::general_purpose::STANDARD, Engine};
  |     ^^^^^^ use of unresolved module or unlinked crate `base64`
  |
  = help: if you wanted to use a crate named `base64`, use `cargo add base64` to add it to your `Cargo.toml`

error[E0432]: unresolved import `futures`
 --> src\commands\ollama.rs:5:5
  |
5 | use futures::StreamExt;
  |     ^^^^^^^ use of unresolved module or unlinked crate `futures`
  |
  = help: if you wanted to use a crate named `futures`, use `cargo add futures` to add it to your `Cargo.toml`

error[E0432]: unresolved import `chrono`
  --> src\commands\sandbox.rs:14:5
   |
14 | use chrono::{DateTime, Utc};
   |     ^^^^^^ use of unresolved module or unlinked crate `chrono`
   |
   = help: if you wanted to use a crate named `chrono`, use `cargo add chrono` to add it to your `Cargo.toml`

error[E0432]: unresolved import `base64`
   --> src\commands\screenshot.rs:253:5
    |
253 | use base64::Engine;
    |     ^^^^^^ use of unresolved module or unlinked crate `base64`
    |
    = help: if you wanted to use a crate named `base64`, use `cargo add base64` to add it to your `Cargo.toml`

error[E0432]: unresolved import `anyhow`
 --> src\commands\vector.rs:1:5
  |
1 | use anyhow::Result;
  |     ^^^^^^ use of unresolved module or unlinked crate `anyhow`
  |
  = help: if you wanted to use a crate named `anyhow`, use `cargo add anyhow` to add it to your `Cargo.toml`

error[E0432]: unresolved import `parking_lot`
 --> src\commands\vector.rs:2:5
  |
2 | use parking_lot::Mutex;
  |     ^^^^^^^^^^^ use of unresolved module or unlinked crate `parking_lot`
  |
  = help: if you wanted to use a crate named `parking_lot`, use `cargo add parking_lot` to add it to your `Cargo.toml`

error[E0432]: unresolved import `parking_lot`
 --> src\context\screen_content.rs:7:5
  |
7 | use parking_lot::RwLock;
  |     ^^^^^^^^^^^ use of unresolved module or unlinked crate `parking_lot`
  |
  = help: if you wanted to use a crate named `parking_lot`, use `cargo add parking_lot` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
 --> src\mcp\client.rs:8:5
  |
8 | use tokio::sync::{mpsc, oneshot, Mutex as TokioMutex};
  |     ^^^^^ use of unresolved module or unlinked crate `tokio`
  |
  = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
 --> src\mcp\manager.rs:9:5
  |
9 | use tokio::sync::{mpsc, RwLock};
  |     ^^^^^ use of unresolved module or unlinked crate `tokio`
  |
  = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
  --> src\mcp\manager.rs:10:5
   |
10 | use tokio::task::JoinHandle;
   |     ^^^^^ use of unresolved module or unlinked crate `tokio`
   |
   = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
  --> src\sandbox\mod.rs:33:5
   |
33 | use tokio::sync::RwLock;
   |     ^^^^^ use of unresolved module or unlinked crate `tokio`
   |
   = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`

error[E0432]: unresolved import `parking_lot`
  --> src\context\mod.rs:26:5
   |
26 | use parking_lot::RwLock;
   |     ^^^^^^^^^^^ use of unresolved module or unlinked crate `parking_lot`
   |
   = help: if you wanted to use a crate named `parking_lot`, use `cargo add parking_lot` to add it to your `Cargo.toml`

error[E0432]: unresolved import `parking_lot`
 --> src\screen_recording\history.rs:4:5
  |
4 | use parking_lot::RwLock;
  |     ^^^^^^^^^^^ use of unresolved module or unlinked crate `parking_lot`
  |
  = help: if you wanted to use a crate named `parking_lot`, use `cargo add parking_lot` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
 --> src\screenshot\region_selector.rs:7:5
  |
7 | use tokio::sync::oneshot;
  |     ^^^^^ use of unresolved module or unlinked crate `tokio`
  |
  = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`

error[E0432]: unresolved import `parking_lot`
  --> src\screen_recording\mod.rs:17:5
   |
17 | use parking_lot::RwLock;
   |     ^^^^^^^^^^^ use of unresolved module or unlinked crate `parking_lot`
   |
   = help: if you wanted to use a crate named `parking_lot`, use `cargo add parking_lot` to add it to your `Cargo.toml`

error[E0432]: unresolved import `parking_lot`
 --> src\screenshot\region_selector.rs:9:5
  |
9 | use parking_lot::Mutex;
  |     ^^^^^^^^^^^ use of unresolved module or unlinked crate `parking_lot`
  |
  = help: if you wanted to use a crate named `parking_lot`, use `cargo add parking_lot` to add it to your `Cargo.toml`

error[E0432]: unresolved import `parking_lot`
 --> src\screenshot\screenshot_history.rs:8:5
  |
8 | use parking_lot::RwLock;
  |     ^^^^^^^^^^^ use of unresolved module or unlinked crate `parking_lot`
  |
  = help: if you wanted to use a crate named `parking_lot`, use `cargo add parking_lot` to add it to your `Cargo.toml`

error[E0432]: unresolved import `arboard`
   --> src\screenshot\mod.rs:200:13
    |
200 |         use arboard::{Clipboard, ImageData};
    |             ^^^^^^^ use of unresolved module or unlinked crate `arboard`
    |
    = help: if you wanted to use a crate named `arboard`, use `cargo add arboard` to add it to your `Cargo.toml`

error[E0432]: unresolved import `parking_lot`
  --> src\selection\enhanced_detector.rs:13:5
   |
13 | use parking_lot::RwLock;
   |     ^^^^^^^^^^^ use of unresolved module or unlinked crate `parking_lot`
   |
   = help: if you wanted to use a crate named `parking_lot`, use `cargo add parking_lot` to add it to your `Cargo.toml`

error[E0432]: unresolved import `parking_lot`
 --> src\selection\mouse_hook.rs:7:5
  |
7 | use parking_lot::RwLock;
  |     ^^^^^^^^^^^ use of unresolved module or unlinked crate `parking_lot`
  |
  = help: if you wanted to use a crate named `parking_lot`, use `cargo add parking_lot` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
  --> src\selection\mouse_hook.rs:13:5
   |
13 | use tokio::sync::mpsc;
   |     ^^^^^ use of unresolved module or unlinked crate `tokio`
   |
   = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`

error[E0432]: unresolved import `rdev`
 --> src\selection\mouse_hook.rs:8:5
  |
8 | use rdev::{Event, EventType};
  |     ^^^^ use of unresolved module or unlinked crate `rdev`
  |
  = help: if you wanted to use a crate named `rdev`, use `cargo add rdev` to add it to your `Cargo.toml`

error[E0432]: unresolved import `parking_lot`
  --> src\selection\history.rs:10:5
   |
10 | use parking_lot::RwLock;
   |     ^^^^^^^^^^^ use of unresolved module or unlinked crate `parking_lot`
   |
   = help: if you wanted to use a crate named `parking_lot`, use `cargo add parking_lot` to add it to your `Cargo.toml`

error[E0432]: unresolved import `parking_lot`
  --> src\selection\clipboard_history.rs:10:5
   |
10 | use parking_lot::RwLock;
   |     ^^^^^^^^^^^ use of unresolved module or unlinked crate `parking_lot`
   |
   = help: if you wanted to use a crate named `parking_lot`, use `cargo add parking_lot` to add it to your `Cargo.toml`

error[E0432]: unresolved import `arboard`
   --> src\selection\clipboard_history.rs:314:13
    |
314 |         use arboard::Clipboard;
    |             ^^^^^^^ use of unresolved module or unlinked crate `arboard`
    |
    = help: if you wanted to use a crate named `arboard`, use `cargo add arboard` to add it to your `Cargo.toml`

error[E0432]: unresolved import `arboard`
   --> src\selection\clipboard_history.rs:375:13
    |
375 |         use arboard::Clipboard;
    |             ^^^^^^^ use of unresolved module or unlinked crate `arboard`
    |
    = help: if you wanted to use a crate named `arboard`, use `cargo add arboard` to add it to your `Cargo.toml`

error[E0432]: unresolved import `parking_lot`
  --> src\selection\smart_selection.rs:10:5
   |
10 | use parking_lot::RwLock;
   |     ^^^^^^^^^^^ use of unresolved module or unlinked crate `parking_lot`
   |
   = help: if you wanted to use a crate named `parking_lot`, use `cargo add parking_lot` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
  --> src\selection\mod.rs:29:5
   |
29 | use tokio::sync::mpsc;
   |     ^^^^^ use of unresolved module or unlinked crate `tokio`
   |
   = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio_util`
  --> src\selection\mod.rs:30:5
   |
30 | use tokio_util::sync::CancellationToken;
   |     ^^^^^^^^^^ use of unresolved module or unlinked crate `tokio_util`
   |
   = help: if you wanted to use a crate named `tokio_util`, use `cargo add tokio_util` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
   --> src\commands\mcp.rs:140:9
    |
140 |     use tokio::process::Command;
    |         ^^^^^ use of unresolved module or unlinked crate `tokio`
    |
    = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
   --> src\commands\mcp.rs:166:9
    |
166 |     use tokio::process::Command;
    |         ^^^^^ use of unresolved module or unlinked crate `tokio`
    |
    = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
   --> src\commands\mcp.rs:192:9
    |
192 |     use tokio::process::Command;
    |         ^^^^^ use of unresolved module or unlinked crate `tokio`
    |
    = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`

error[E0432]: unresolved import `parking_lot`
  --> src\selection\mod.rs:27:5
   |
27 | use parking_lot::RwLock;
   |     ^^^^^^^^^^^ use of unresolved module or unlinked crate `parking_lot`
   |
   = help: if you wanted to use a crate named `parking_lot`, use `cargo add parking_lot` to add it to your `Cargo.toml`

error[E0432]: unresolved import `thiserror`
 --> src\mcp\error.rs:7:5
  |
7 | use thiserror::Error;
  |     ^^^^^^^^^ use of unresolved module or unlinked crate `thiserror`
  |
  = help: if you wanted to use a crate named `thiserror`, use `cargo add thiserror` to add it to your `Cargo.toml`

error[E0432]: unresolved import `async_trait`
 --> src\mcp\transport\sse.rs:5:5
  |
5 | use async_trait::async_trait;
  |     ^^^^^^^^^^^ use of unresolved module or unlinked crate `async_trait`
  |
  = help: if you wanted to use a crate named `async_trait`, use `cargo add async_trait` to add it to your `Cargo.toml`

error[E0432]: unresolved import `futures`
 --> src\mcp\transport\sse.rs:6:5
  |
6 | use futures::StreamExt;
  |     ^^^^^^^ use of unresolved module or unlinked crate `futures`
  |
  = help: if you wanted to use a crate named `futures`, use `cargo add futures` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
  --> src\mcp\transport\sse.rs:10:5
   |
10 | use tokio::sync::{mpsc, Mutex as TokioMutex};
   |     ^^^^^ use of unresolved module or unlinked crate `tokio`
   |
   = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`

error[E0432]: unresolved import `reqwest_eventsource`
 --> src\mcp\transport\sse.rs:7:5
  |
7 | use reqwest_eventsource::{Event, EventSource};
  |     ^^^^^^^^^^^^^^^^^^^ use of unresolved module or unlinked crate `reqwest_eventsource`
  |
  = help: if you wanted to use a crate named `reqwest_eventsource`, use `cargo add reqwest_eventsource` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
 --> src\mcp\transport\stdio.rs:9:5
  |
9 | use tokio::io::{AsyncBufReadExt, AsyncWriteExt, BufReader};
  |     ^^^^^ use of unresolved module or unlinked crate `tokio`
  |
  = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
  --> src\mcp\transport\stdio.rs:10:5
   |
10 | use tokio::process::{Child, ChildStdin, ChildStdout, Command};
   |     ^^^^^ use of unresolved module or unlinked crate `tokio`
   |
   = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
  --> src\mcp\transport\stdio.rs:11:5
   |
11 | use tokio::sync::Mutex as TokioMutex;
   |     ^^^^^ use of unresolved module or unlinked crate `tokio`
   |
   = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`

error[E0432]: unresolved import `async_trait`
 --> src\mcp\transport\stdio.rs:5:5
  |
5 | use async_trait::async_trait;
  |     ^^^^^^^^^^^ use of unresolved module or unlinked crate `async_trait`
  |
  = help: if you wanted to use a crate named `async_trait`, use `cargo add async_trait` to add it to your `Cargo.toml`

error[E0432]: unresolved import `async_trait`
 --> src\mcp\transport\mod.rs:8:5
  |
8 | use async_trait::async_trait;
  |     ^^^^^^^^^^^ use of unresolved module or unlinked crate `async_trait`
  |
  = help: if you wanted to use a crate named `async_trait`, use `cargo add async_trait` to add it to your `Cargo.toml`

error[E0432]: unresolved import `chrono`
 --> src\sandbox\db.rs:6:5
  |
6 | use chrono::{DateTime, Utc};
  |     ^^^^^^ use of unresolved module or unlinked crate `chrono`
  |
  = help: if you wanted to use a crate named `chrono`, use `cargo add chrono` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
 --> src\sandbox\docker.rs:9:5
  |
9 | use tokio::io::AsyncWriteExt;
  |     ^^^^^ use of unresolved module or unlinked crate `tokio`
  |
  = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
  --> src\sandbox\docker.rs:10:5
   |
10 | use tokio::process::Command;
   |     ^^^^^ use of unresolved module or unlinked crate `tokio`
   |
   = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
  --> src\sandbox\docker.rs:11:5
   |
11 | use tokio::time::timeout;
   |     ^^^^^ use of unresolved module or unlinked crate `tokio`
   |
   = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`

error[E0432]: unresolved import `async_trait`
 --> src\sandbox\docker.rs:5:5
  |
5 | use async_trait::async_trait;
  |     ^^^^^^^^^^^ use of unresolved module or unlinked crate `async_trait`
  |
  = help: if you wanted to use a crate named `async_trait`, use `cargo add async_trait` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
 --> src\sandbox\native.rs:9:5
  |
9 | use tokio::io::AsyncWriteExt;
  |     ^^^^^ use of unresolved module or unlinked crate `tokio`
  |
  = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
  --> src\sandbox\native.rs:10:5
   |
10 | use tokio::process::Command;
   |     ^^^^^ use of unresolved module or unlinked crate `tokio`
   |
   = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
  --> src\sandbox\native.rs:11:5
   |
11 | use tokio::time::timeout;
   |     ^^^^^ use of unresolved module or unlinked crate `tokio`
   |
   = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`

error[E0432]: unresolved import `async_trait`
 --> src\sandbox\native.rs:5:5
  |
5 | use async_trait::async_trait;
  |     ^^^^^^^^^^^ use of unresolved module or unlinked crate `async_trait`
  |
  = help: if you wanted to use a crate named `async_trait`, use `cargo add async_trait` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
 --> src\sandbox\podman.rs:9:5
  |
9 | use tokio::io::AsyncWriteExt;
  |     ^^^^^ use of unresolved module or unlinked crate `tokio`
  |
  = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
  --> src\sandbox\podman.rs:10:5
   |
10 | use tokio::process::Command;
   |     ^^^^^ use of unresolved module or unlinked crate `tokio`
   |
   = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
  --> src\sandbox\podman.rs:11:5
   |
11 | use tokio::time::timeout;
   |     ^^^^^ use of unresolved module or unlinked crate `tokio`
   |
   = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`

error[E0432]: unresolved import `async_trait`
 --> src\sandbox\podman.rs:5:5
  |
5 | use async_trait::async_trait;
  |     ^^^^^^^^^^^ use of unresolved module or unlinked crate `async_trait`
  |
  = help: if you wanted to use a crate named `async_trait`, use `cargo add async_trait` to add it to your `Cargo.toml`

error[E0432]: unresolved import `async_trait`
 --> src\sandbox\runtime.rs:5:5
  |
5 | use async_trait::async_trait;
  |     ^^^^^^^^^^^ use of unresolved module or unlinked crate `async_trait`
  |
  = help: if you wanted to use a crate named `async_trait`, use `cargo add async_trait` to add it to your `Cargo.toml`

error[E0432]: unresolved import `thiserror`
 --> src\sandbox\runtime.rs:9:5
  |
9 | use thiserror::Error;
  |     ^^^^^^^^^ use of unresolved module or unlinked crate `thiserror`
  |
  = help: if you wanted to use a crate named `thiserror`, use `cargo add thiserror` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
   --> src\selection\mod.rs:179:17
    |
179 |                 tokio::select! {
    |                 ^^^^^ use of unresolved module or unlinked crate `tokio`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
   --> src\selection\toolbar_window.rs:114:13
    |
114 |             tokio::select! {
    |             ^^^^^ use of unresolved module or unlinked crate `tokio`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `thiserror`
  --> src\sandbox\db.rs:15:17
   |
15 | #[derive(Debug, thiserror::Error)]
   |                 ^^^^^^^^^ use of unresolved module or unlinked crate `thiserror`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
   --> src\mcp\manager.rs:862:21
    |
862 |                     tokio::select! {
    |                     ^^^^^ use of unresolved module or unlinked crate `tokio`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
   --> src\mcp\manager.rs:575:17
    |
575 |                 tokio::select! {
    |                 ^^^^^ use of unresolved module or unlinked crate `tokio`

error: cannot find attribute `error` in this scope
  --> src\sandbox\runtime.rs:18:7
   |
18 |     #[error("Runtime not available: {0}")]
   |       ^^^^^

error: cannot find attribute `error` in this scope
  --> src\sandbox\runtime.rs:21:7
   |
21 |     #[error("Language not supported: {0}")]
   |       ^^^^^

error: cannot find attribute `error` in this scope
  --> src\sandbox\runtime.rs:24:7
   |
24 |     #[error("Execution timeout after {0} seconds")]
   |       ^^^^^

error: cannot find attribute `error` in this scope
  --> src\sandbox\runtime.rs:27:7
   |
27 |     #[error("Execution failed: {0}")]
   |       ^^^^^

error: cannot find attribute `error` in this scope
  --> src\sandbox\runtime.rs:30:7
   |
30 |     #[error("Container error: {0}")]
   |       ^^^^^

error: cannot find attribute `error` in this scope
  --> src\sandbox\runtime.rs:33:7
   |
33 |     #[error("Configuration error: {0}")]
   |       ^^^^^

error: cannot find attribute `error` in this scope
  --> src\sandbox\runtime.rs:36:7
   |
36 |     #[error("IO error: {0}")]
   |       ^^^^^

error: cannot find attribute `from` in this scope
  --> src\sandbox\runtime.rs:37:10
   |
37 |     Io(#[from] std::io::Error),
   |          ^^^^

error: cannot find attribute `error` in this scope
  --> src\sandbox\runtime.rs:39:7
   |
39 |     #[error("Resource limit exceeded: {0}")]
   |       ^^^^^

error: cannot find attribute `error` in this scope
  --> src\sandbox\runtime.rs:42:7
   |
42 |     #[error("Security violation: {0}")]
   |       ^^^^^

error: cannot find attribute `error` in this scope
  --> src\sandbox\db.rs:17:7
   |
17 |     #[error("SQLite error: {0}")]
   |       ^^^^^

error: cannot find attribute `from` in this scope
  --> src\sandbox\db.rs:18:14
   |
18 |     Sqlite(#[from] rusqlite::Error),
   |              ^^^^

error: cannot find attribute `error` in this scope
  --> src\sandbox\db.rs:20:7
   |
20 |     #[error("Lock error: {0}")]
   |       ^^^^^

error: cannot find attribute `error` in this scope
  --> src\sandbox\db.rs:23:7
   |
23 |     #[error("Not found: {0}")]
   |       ^^^^^

error: cannot find attribute `error` in this scope
  --> src\sandbox\db.rs:26:7
   |
26 |     #[error("Serialization error: {0}")]
   |       ^^^^^

error: cannot find attribute `error` in this scope
  --> src\mcp\error.rs:14:7
   |
14 |     #[error("Failed to spawn process: {0}")]
   |       ^^^^^

error: cannot find attribute `error` in this scope
  --> src\mcp\error.rs:17:7
   |
17 |     #[error("stdin unavailable")]
   |       ^^^^^

error: cannot find attribute `error` in this scope
  --> src\mcp\error.rs:20:7
   |
20 |     #[error("stdout unavailable")]
   |       ^^^^^

error: cannot find attribute `error` in this scope
  --> src\mcp\error.rs:23:7
   |
23 |     #[error("IO error: {0}")]
   |       ^^^^^

error: cannot find attribute `from` in this scope
  --> src\mcp\error.rs:24:15
   |
24 |     IoError(#[from] std::io::Error),
   |               ^^^^

error: cannot find attribute `error` in this scope
  --> src\mcp\error.rs:26:7
   |
26 |     #[error("JSON error: {0}")]
   |       ^^^^^

error: cannot find attribute `from` in this scope
  --> src\mcp\error.rs:27:17
   |
27 |     JsonError(#[from] serde_json::Error),
   |                 ^^^^

error: cannot find attribute `error` in this scope
  --> src\mcp\error.rs:29:7
   |
29 |     #[error("Server not found: {0}")]
   |       ^^^^^

error: cannot find attribute `error` in this scope
  --> src\mcp\error.rs:32:7
   |
32 |     #[error("Not connected to server")]
   |       ^^^^^

error: cannot find attribute `error` in this scope
  --> src\mcp\error.rs:35:7
   |
35 |     #[error("Missing URL for SSE connection")]
   |       ^^^^^

error: cannot find attribute `error` in this scope
  --> src\mcp\error.rs:38:7
   |
38 |     #[error("RPC error: code={code}, message={message}")]
   |       ^^^^^

error: cannot find attribute `error` in this scope
  --> src\mcp\error.rs:45:7
   |
45 |     #[error("Channel closed")]
   |       ^^^^^

error: cannot find attribute `error` in this scope
  --> src\mcp\error.rs:48:7
   |
48 |     #[error("Empty response")]
   |       ^^^^^

error: cannot find attribute `error` in this scope
  --> src\mcp\error.rs:51:7
   |
51 |     #[error("Config path error: {0}")]
   |       ^^^^^

error: cannot find attribute `error` in this scope
  --> src\mcp\error.rs:54:7
   |
54 |     #[error("Connection timeout")]
   |       ^^^^^

error: cannot find attribute `error` in this scope
  --> src\mcp\error.rs:57:7
   |
57 |     #[error("Initialization failed: {0}")]
   |       ^^^^^

error: cannot find attribute `error` in this scope
  --> src\mcp\error.rs:60:7
   |
60 |     #[error("Request error: {0}")]
   |       ^^^^^

error: cannot find attribute `from` in this scope
  --> src\mcp\error.rs:61:20
   |
61 |     RequestError(#[from] reqwest::Error),
   |                    ^^^^

error: cannot find attribute `error` in this scope
  --> src\mcp\error.rs:63:7
   |
63 |     #[error("Invalid message format: {0}")]
   |       ^^^^^

error: cannot find attribute `error` in this scope
  --> src\mcp\error.rs:66:7
   |
66 |     #[error("Server already connected")]
   |       ^^^^^

error: cannot find attribute `error` in this scope
  --> src\mcp\error.rs:69:7
   |
69 |     #[error("Transport error: {0}")]
   |       ^^^^^

error: cannot find attribute `error` in this scope
  --> src\mcp\error.rs:72:7
   |
72 |     #[error("Protocol error: {0}")]
   |       ^^^^^

error: cannot find attribute `error` in this scope
  --> src\mcp\error.rs:75:7
   |
75 |     #[error("Unsupported capability: {0}")]
   |       ^^^^^

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `chrono`
   --> src\awareness\activity_tracker.rs:148:19
    |
148 |         let now = chrono::Utc::now().timestamp_millis();
    |                   ^^^^^^ use of unresolved module or unlinked crate `chrono`
    |
    = help: if you wanted to use a crate named `chrono`, use `cargo add chrono` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `chrono`
   --> src\awareness\activity_tracker.rs:251:24
    |
251 |             timestamp: chrono::Utc::now().timestamp_millis(),
    |                        ^^^^^^ use of unresolved module or unlinked crate `chrono`
    |
    = help: if you wanted to use a crate named `chrono`, use `cargo add chrono` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `chrono`
   --> src\awareness\activity_tracker.rs:273:24
    |
273 |             timestamp: chrono::Utc::now().timestamp_millis(),
    |                        ^^^^^^ use of unresolved module or unlinked crate `chrono`
    |
    = help: if you wanted to use a crate named `chrono`, use `cargo add chrono` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `chrono`
   --> src\awareness\activity_tracker.rs:292:24
    |
292 |             timestamp: chrono::Utc::now().timestamp_millis(),
    |                        ^^^^^^ use of unresolved module or unlinked crate `chrono`
    |
    = help: if you wanted to use a crate named `chrono`, use `cargo add chrono` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `chrono`
   --> src\awareness\activity_tracker.rs:305:24
    |
305 |             timestamp: chrono::Utc::now().timestamp_millis(),
    |                        ^^^^^^ use of unresolved module or unlinked crate `chrono`
    |
    = help: if you wanted to use a crate named `chrono`, use `cargo add chrono` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `chrono`
  --> src\awareness\smart_suggestions.rs:92:27
   |
92 |                 let now = chrono::Utc::now().timestamp_millis();
   |                           ^^^^^^ use of unresolved module or unlinked crate `chrono`
   |
   = help: if you wanted to use a crate named `chrono`, use `cargo add chrono` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `chrono`
   --> src\awareness\focus_tracker.rs:116:19
    |
116 |         let now = chrono::Utc::now().timestamp_millis();
    |                   ^^^^^^ use of unresolved module or unlinked crate `chrono`
    |
    = help: if you wanted to use a crate named `chrono`, use `cargo add chrono` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `chrono`
   --> src\awareness\focus_tracker.rs:140:19
    |
140 |         let now = chrono::Utc::now().timestamp_millis();
    |                   ^^^^^^ use of unresolved module or unlinked crate `chrono`
    |
    = help: if you wanted to use a crate named `chrono`, use `cargo add chrono` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `chrono`
   --> src\awareness\focus_tracker.rs:168:23
    |
168 |             let now = chrono::Utc::now().timestamp_millis();
    |                       ^^^^^^ use of unresolved module or unlinked crate `chrono`
    |
    = help: if you wanted to use a crate named `chrono`, use `cargo add chrono` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `chrono`
   --> src\awareness\focus_tracker.rs:276:26
    |
276 |         let date_start = chrono::NaiveDate::parse_from_str(date, "%Y-%m-%d")
    |                          ^^^^^^ use of unresolved module or unlinked crate `chrono`
    |
    = help: if you wanted to use a crate named `chrono`, use `cargo add chrono` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `chrono`
   --> src\awareness\focus_tracker.rs:312:21
    |
312 |         let today = chrono::Utc::now().format("%Y-%m-%d").to_string();
    |                     ^^^^^^ use of unresolved module or unlinked crate `chrono`
    |
    = help: if you wanted to use a crate named `chrono`, use `cargo add chrono` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `chrono`
  --> src\awareness\mod.rs:73:24
   |
73 |             timestamp: chrono::Utc::now().timestamp_millis(),
   |                        ^^^^^^ use of unresolved module or unlinked crate `chrono`
   |
   = help: if you wanted to use a crate named `chrono`, use `cargo add chrono` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
   --> src\awareness\mod.rs:120:17
    |
120 |                 tokio::time::sleep(tokio::time::Duration::from_secs(60)).await;
    |                 ^^^^^ use of unresolved module or unlinked crate `tokio`
    |
    = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `chrono`
  --> src\commands\awareness.rs:50:20
   |
50 |         timestamp: chrono::Utc::now().timestamp_millis(),
   |                    ^^^^^^ use of unresolved module or unlinked crate `chrono`
   |
   = help: if you wanted to use a crate named `chrono`, use `cargo add chrono` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `png`
  --> src\commands\clipboard.rs:28:35
   |
28 |                 let mut encoder = png::Encoder::new(&mut png_data, width, height);
   |                                   ^^^ use of unresolved module or unlinked crate `png`
   |
   = help: if you wanted to use a crate named `png`, use `cargo add png` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `png`
  --> src\commands\clipboard.rs:29:35
   |
29 |                 encoder.set_color(png::ColorType::Rgba);
   |                                   ^^^ use of unresolved module or unlinked crate `png`
   |
   = help: if you wanted to use a crate named `png`, use `cargo add png` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `png`
  --> src\commands\clipboard.rs:30:35
   |
30 |                 encoder.set_depth(png::BitDepth::Eight);
   |                                   ^^^ use of unresolved module or unlinked crate `png`
   |
   = help: if you wanted to use a crate named `png`, use `cargo add png` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `chrono`
  --> src\commands\environment.rs:75:15
   |
75 |     let now = chrono::Utc::now().to_rfc3339();
   |               ^^^^^^ use of unresolved module or unlinked crate `chrono`
   |
   = help: if you wanted to use a crate named `chrono`, use `cargo add chrono` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `chrono`
   --> src\commands\environment.rs:166:40
    |
166 |                     last_checked: Some(chrono::Utc::now().to_rfc3339()),
    |                                        ^^^^^^ use of unresolved module or unlinked crate `chrono`
    |
    = help: if you wanted to use a crate named `chrono`, use `cargo add chrono` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
   --> src\commands\environment.rs:221:5
    |
221 |     tokio::time::sleep(tokio::time::Duration::from_secs(2)).await;
    |     ^^^^^ use of unresolved module or unlinked crate `tokio`
    |
    = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `chrono`
   --> src\commands\environment.rs:913:35
    |
913 |         id: format!("venv-{}-{}", chrono::Utc::now().timestamp_millis(), &name[..name.len().min(6)]),
    |                                   ^^^^^^ use of unresolved module or unlinked crate `chrono`
    |
    = help: if you wanted to use a crate named `chrono`, use `cargo add chrono` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `chrono`
   --> src\commands\environment.rs:922:21
    |
922 |         created_at: chrono::Utc::now().to_rfc3339(),
    |                     ^^^^^^ use of unresolved module or unlinked crate `chrono`
    |
    = help: if you wanted to use a crate named `chrono`, use `cargo add chrono` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `reqwest`
  --> src\commands\ollama.rs:83:18
   |
83 |     let client = reqwest::Client::builder()
   |                  ^^^^^^^ use of unresolved module or unlinked crate `reqwest`
   |
   = help: if you wanted to use a crate named `reqwest`, use `cargo add reqwest` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `reqwest`
   --> src\commands\ollama.rs:133:18
    |
133 |     let client = reqwest::Client::new();
    |                  ^^^^^^^ use of unresolved module or unlinked crate `reqwest`
    |
    = help: if you wanted to use a crate named `reqwest`, use `cargo add reqwest` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `reqwest`
   --> src\commands\ollama.rs:167:18
    |
167 |     let client = reqwest::Client::new();
    |                  ^^^^^^^ use of unresolved module or unlinked crate `reqwest`
    |
    = help: if you wanted to use a crate named `reqwest`, use `cargo add reqwest` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `reqwest`
   --> src\commands\ollama.rs:196:18
    |
196 |     let client = reqwest::Client::new();
    |                  ^^^^^^^ use of unresolved module or unlinked crate `reqwest`
    |
    = help: if you wanted to use a crate named `reqwest`, use `cargo add reqwest` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `reqwest`
   --> src\commands\ollama.rs:269:18
    |
269 |     let client = reqwest::Client::new();
    |                  ^^^^^^^ use of unresolved module or unlinked crate `reqwest`
    |
    = help: if you wanted to use a crate named `reqwest`, use `cargo add reqwest` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `reqwest`
   --> src\commands\ollama.rs:290:18
    |
290 |     let client = reqwest::Client::new();
    |                  ^^^^^^^ use of unresolved module or unlinked crate `reqwest`
    |
    = help: if you wanted to use a crate named `reqwest`, use `cargo add reqwest` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `reqwest`
   --> src\commands\ollama.rs:328:18
    |
328 |     let client = reqwest::Client::new();
    |                  ^^^^^^^ use of unresolved module or unlinked crate `reqwest`
    |
    = help: if you wanted to use a crate named `reqwest`, use `cargo add reqwest` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `reqwest`
   --> src\commands\ollama.rs:356:18
    |
356 |     let client = reqwest::Client::new();
    |                  ^^^^^^^ use of unresolved module or unlinked crate `reqwest`
    |
    = help: if you wanted to use a crate named `reqwest`, use `cargo add reqwest` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `reqwest`
   --> src\commands\ollama.rs:398:18
    |
398 |     let client = reqwest::Client::new();
    |                  ^^^^^^^ use of unresolved module or unlinked crate `reqwest`
    |
    = help: if you wanted to use a crate named `reqwest`, use `cargo add reqwest` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `reqwest`
   --> src\commands\proxy.rs:168:18
    |
168 |     let client = reqwest::Client::builder()
    |                  ^^^^^^^ use of unresolved module or unlinked crate `reqwest`
    |
    = help: if you wanted to use a crate named `reqwest`, use `cargo add reqwest` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `reqwest`
   --> src\commands\proxy.rs:269:17
    |
269 |     let proxy = reqwest::Proxy::all(&proxy_url).map_err(|e| e.to_string())?;
    |                 ^^^^^^^ use of unresolved module or unlinked crate `reqwest`
    |
    = help: if you wanted to use a crate named `reqwest`, use `cargo add reqwest` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `reqwest`
   --> src\commands\proxy.rs:271:18
    |
271 |     let client = reqwest::Client::builder()
    |                  ^^^^^^^ use of unresolved module or unlinked crate `reqwest`
    |
    = help: if you wanted to use a crate named `reqwest`, use `cargo add reqwest` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `reqwest`
   --> src\commands\proxy.rs:450:18
    |
450 |     let client = reqwest::Client::builder()
    |                  ^^^^^^^ use of unresolved module or unlinked crate `reqwest`
    |
    = help: if you wanted to use a crate named `reqwest`, use `cargo add reqwest` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `uuid`
  --> src\commands\sandbox.rs:67:13
   |
67 |         id: uuid::Uuid::new_v4().to_string(),
   |             ^^^^ use of unresolved module or unlinked crate `uuid`
   |
   = help: if you wanted to use a crate named `uuid`, use `cargo add uuid` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `uuid`
   --> src\commands\sandbox.rs:479:13
    |
479 |         id: uuid::Uuid::new_v4().to_string(),
    |             ^^^^ use of unresolved module or unlinked crate `uuid`
    |
    = help: if you wanted to use a crate named `uuid`, use `cargo add uuid` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `uuid`
   --> src\commands\sandbox.rs:655:13
    |
655 |         id: uuid::Uuid::new_v4().to_string(),
    |             ^^^^ use of unresolved module or unlinked crate `uuid`
    |
    = help: if you wanted to use a crate named `uuid`, use `cargo add uuid` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `base64`
  --> src\commands\screenshot.rs:19:23
   |
19 |         image_base64: base64::engine::general_purpose::STANDARD.encode(&result.image_data),
   |                       ^^^^^^ use of unresolved module or unlinked crate `base64`
   |
   = help: if you wanted to use a crate named `base64`, use `cargo add base64` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `base64`
  --> src\commands\screenshot.rs:31:23
   |
31 |         image_base64: base64::engine::general_purpose::STANDARD.encode(&result.image_data),
   |                       ^^^^^^ use of unresolved module or unlinked crate `base64`
   |
   = help: if you wanted to use a crate named `base64`, use `cargo add base64` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `base64`
  --> src\commands\screenshot.rs:48:23
   |
48 |         image_base64: base64::engine::general_purpose::STANDARD.encode(&result.image_data),
   |                       ^^^^^^ use of unresolved module or unlinked crate `base64`
   |
   = help: if you wanted to use a crate named `base64`, use `cargo add base64` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `base64`
  --> src\commands\screenshot.rs:67:22
   |
67 |     let image_data = base64::engine::general_purpose::STANDARD
   |                      ^^^^^^ use of unresolved module or unlinked crate `base64`
   |
   = help: if you wanted to use a crate named `base64`, use `cargo add base64` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `base64`
   --> src\commands\screenshot.rs:107:22
    |
107 |     let image_data = base64::engine::general_purpose::STANDARD
    |                      ^^^^^^ use of unresolved module or unlinked crate `base64`
    |
    = help: if you wanted to use a crate named `base64`, use `cargo add base64` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `base64`
   --> src\commands\screenshot.rs:187:22
    |
187 |     let image_data = base64::engine::general_purpose::STANDARD
    |                      ^^^^^^ use of unresolved module or unlinked crate `base64`
    |
    = help: if you wanted to use a crate named `base64`, use `cargo add base64` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `base64`
   --> src\commands\screenshot.rs:212:23
    |
212 |         image_base64: base64::engine::general_purpose::STANDARD.encode(&result.image_data),
    |                       ^^^^^^ use of unresolved module or unlinked crate `base64`
    |
    = help: if you wanted to use a crate named `base64`, use `cargo add base64` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `base64`
   --> src\commands\screenshot.rs:224:23
    |
224 |         image_base64: base64::engine::general_purpose::STANDARD.encode(&result.image_data),
    |                       ^^^^^^ use of unresolved module or unlinked crate `base64`
    |
    = help: if you wanted to use a crate named `base64`, use `cargo add base64` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `base64`
   --> src\commands\screenshot.rs:241:23
    |
241 |         image_base64: base64::engine::general_purpose::STANDARD.encode(&result.image_data),
    |                       ^^^^^^ use of unresolved module or unlinked crate `base64`
    |
    = help: if you wanted to use a crate named `base64`, use `cargo add base64` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `chrono`
   --> src\commands\selection.rs:178:20
    |
178 |         timestamp: chrono::Utc::now().timestamp_millis(),
    |                    ^^^^^^ use of unresolved module or unlinked crate `chrono`
    |
    = help: if you wanted to use a crate named `chrono`, use `cargo add chrono` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `mouse_position`
   --> src\commands\selection.rs:194:11
    |
194 |     match mouse_position::mouse_position::Mouse::get_mouse_position() {
    |           ^^^^^^^^^^^^^^ use of unresolved module or unlinked crate `mouse_position`
    |
    = help: if you wanted to use a crate named `mouse_position`, use `cargo add mouse_position` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `mouse_position`
   --> src\commands\selection.rs:195:9
    |
195 |         mouse_position::mouse_position::Mouse::Position { x, y } => (x as f64, y as f64),
    |         ^^^^^^^^^^^^^^ use of unresolved module or unlinked crate `mouse_position`
    |
    = help: if you wanted to use a crate named `mouse_position`, use `cargo add mouse_position` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `mouse_position`
   --> src\commands\selection.rs:196:9
    |
196 |         mouse_position::mouse_position::Mouse::Error => (0.0, 0.0),
    |         ^^^^^^^^^^^^^^ use of unresolved module or unlinked crate `mouse_position`
    |
    = help: if you wanted to use a crate named `mouse_position`, use `cargo add mouse_position` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
   --> src\commands\selection.rs:595:9
    |
595 |         tokio::time::sleep(tokio::time::Duration::from_millis(50)).await;
    |         ^^^^^ use of unresolved module or unlinked crate `tokio`
    |
    = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `regex`
   --> src\context\file_context.rs:121:13
    |
121 |             regex::Regex::new(r"([A-Za-z]:\\[^\s\-—\[\]]+\.[a-zA-Z0-9]+)").ok(),
    |             ^^^^^ use of unresolved module or unlinked crate `regex`
    |
    = help: if you wanted to use a crate named `regex`, use `cargo add regex` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `regex`
   --> src\context\file_context.rs:123:13
    |
123 |             regex::Regex::new(r"(/[^\s\-—\[\]]+\.[a-zA-Z0-9]+)").ok(),
    |             ^^^^^ use of unresolved module or unlinked crate `regex`
    |
    = help: if you wanted to use a crate named `regex`, use `cargo add regex` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `regex`
   --> src\context\file_context.rs:125:13
    |
125 |             regex::Regex::new(r"([a-zA-Z0-9_\-\.]+\.[a-zA-Z0-9]+)").ok(),
    |             ^^^^^ use of unresolved module or unlinked crate `regex`
    |
    = help: if you wanted to use a crate named `regex`, use `cargo add regex` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `regex`
   --> src\context\browser_context.rs:254:28
    |
254 |         let domain_regex = regex::Regex::new(r"([a-zA-Z0-9][-a-zA-Z0-9]*\.)+[a-zA-Z]{2,}").ok()?;
    |                            ^^^^^ use of unresolved module or unlinked crate `regex`
    |
    = help: if you wanted to use a crate named `regex`, use `cargo add regex` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `chrono`
   --> src\context\screen_content.rs:102:27
    |
102 |                 let now = chrono::Utc::now().timestamp_millis();
    |                           ^^^^^^ use of unresolved module or unlinked crate `chrono`
    |
    = help: if you wanted to use a crate named `chrono`, use `cargo add chrono` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `chrono`
   --> src\context\screen_content.rs:128:24
    |
128 |             timestamp: chrono::Utc::now().timestamp_millis(),
    |                        ^^^^^^ use of unresolved module or unlinked crate `chrono`
    |
    = help: if you wanted to use a crate named `chrono`, use `cargo add chrono` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `chrono`
  --> src\context\mod.rs:67:27
   |
67 |                 let now = chrono::Utc::now().timestamp_millis();
   |                           ^^^^^^ use of unresolved module or unlinked crate `chrono`
   |
   = help: if you wanted to use a crate named `chrono`, use `cargo add chrono` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `chrono`
   --> src\context\mod.rs:112:24
    |
112 |             timestamp: chrono::Utc::now().timestamp_millis(),
    |                        ^^^^^^ use of unresolved module or unlinked crate `chrono`
    |
    = help: if you wanted to use a crate named `chrono`, use `cargo add chrono` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `reqwest`
  --> src\http.rs:78:17
   |
78 |     let proxy = reqwest::Proxy::all(proxy_url)?;
   |                 ^^^^^^^ use of unresolved module or unlinked crate `reqwest`
   |
   = help: if you wanted to use a crate named `reqwest`, use `cargo add reqwest` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
  --> src\mcp\client.rs:42:37
   |
42 |     receive_task: TokioMutex<Option<tokio::task::JoinHandle<()>>>,
   |                                     ^^^^^ use of unresolved module or unlinked crate `tokio`
   |
   = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
   --> src\mcp\client.rs:167:15
    |
167 |         match tokio::time::timeout(std::time::Duration::from_secs(30), rx).await {
    |               ^^^^^ use of unresolved module or unlinked crate `tokio`
    |
    = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `chrono`
   --> src\mcp\manager.rs:124:48
    |
124 |             instance.state.connected_at = Some(chrono::Utc::now().timestamp());
    |                                                ^^^^^^ use of unresolved module or unlinked crate `chrono`
    |
    = help: if you wanted to use a crate named `chrono`, use `cargo add chrono` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `uuid`
   --> src\mcp\manager.rs:429:23
    |
429 |         let call_id = uuid::Uuid::new_v4().to_string();
    |                       ^^^^ use of unresolved module or unlinked crate `uuid`
    |
    = help: if you wanted to use a crate named `uuid`, use `cargo add uuid` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `chrono`
   --> src\mcp\manager.rs:430:26
    |
430 |         let started_at = chrono::Utc::now().timestamp_millis();
    |                          ^^^^^^ use of unresolved module or unlinked crate `chrono`
    |
    = help: if you wanted to use a crate named `chrono`, use `cargo add chrono` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `chrono`
   --> src\mcp\manager.rs:454:24
    |
454 |         let ended_at = chrono::Utc::now().timestamp_millis();
    |                        ^^^^^^ use of unresolved module or unlinked crate `chrono`
    |
    = help: if you wanted to use a crate named `chrono`, use `cargo add chrono` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
   --> src\mcp\manager.rs:777:13
    |
777 |             tokio::time::sleep(Duration::from_millis(delay_ms)).await;
    |             ^^^^^ use of unresolved module or unlinked crate `tokio`
    |
    = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `reqwest`
  --> src\mcp\transport\sse.rs:34:22
   |
34 |         let client = reqwest::Client::builder()
   |                      ^^^^^^^ use of unresolved module or unlinked crate `reqwest`
   |
   = help: if you wanted to use a crate named `reqwest`, use `cargo add reqwest` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
  --> src\mcp\transport\sse.rs:76:9
   |
76 |         tokio::time::sleep(std::time::Duration::from_millis(100)).await;
   |         ^^^^^ use of unresolved module or unlinked crate `tokio`
   |
   = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `uuid`
   --> src\sandbox\db.rs:895:17
    |
895 |             id: uuid::Uuid::new_v4().to_string(),
    |                 ^^^^ use of unresolved module or unlinked crate `uuid`
    |
    = help: if you wanted to use a crate named `uuid`, use `cargo add uuid` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `uuid`
   --> src\sandbox\db.rs:917:18
    |
917 |         let id = uuid::Uuid::new_v4().to_string();
    |                  ^^^^ use of unresolved module or unlinked crate `uuid`
    |
    = help: if you wanted to use a crate named `uuid`, use `cargo add uuid` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `uuid`
   --> src\sandbox\runtime.rs:121:17
    |
121 |             id: uuid::Uuid::new_v4().to_string(),
    |                 ^^^^ use of unresolved module or unlinked crate `uuid`
    |
    = help: if you wanted to use a crate named `uuid`, use `cargo add uuid` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `chrono`
  --> src\screen_recording\recorder.rs:75:23
   |
75 |             let now = chrono::Utc::now().timestamp_millis();
   |                       ^^^^^^ use of unresolved module or unlinked crate `chrono`
   |
   = help: if you wanted to use a crate named `chrono`, use `cargo add chrono` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
   --> src\screen_recording\recorder.rs:131:17
    |
131 |                 tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
    |                 ^^^^^ use of unresolved module or unlinked crate `tokio`
    |
    = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `chrono`
   --> src\screen_recording\recorder.rs:142:37
    |
142 |             state.start_time = Some(chrono::Utc::now().timestamp_millis());
    |                                     ^^^^^^ use of unresolved module or unlinked crate `chrono`
    |
    = help: if you wanted to use a crate named `chrono`, use `cargo add chrono` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
   --> src\screen_recording\recorder.rs:181:17
    |
181 |                 tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
    |                 ^^^^^ use of unresolved module or unlinked crate `tokio`
    |
    = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `chrono`
   --> src\screen_recording\recorder.rs:191:37
    |
191 |             state.start_time = Some(chrono::Utc::now().timestamp_millis());
    |                                     ^^^^^^ use of unresolved module or unlinked crate `chrono`
    |
    = help: if you wanted to use a crate named `chrono`, use `cargo add chrono` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
   --> src\screen_recording\recorder.rs:226:17
    |
226 |                 tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
    |                 ^^^^^ use of unresolved module or unlinked crate `tokio`
    |
    = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `chrono`
   --> src\screen_recording\recorder.rs:236:37
    |
236 |             state.start_time = Some(chrono::Utc::now().timestamp_millis());
    |                                     ^^^^^^ use of unresolved module or unlinked crate `chrono`
    |
    = help: if you wanted to use a crate named `chrono`, use `cargo add chrono` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `chrono`
   --> src\screen_recording\recorder.rs:251:33
    |
251 |         state.pause_time = Some(chrono::Utc::now().timestamp_millis());
    |                                 ^^^^^^ use of unresolved module or unlinked crate `chrono`
    |
    = help: if you wanted to use a crate named `chrono`, use `cargo add chrono` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `chrono`
   --> src\screen_recording\recorder.rs:266:23
    |
266 |             let now = chrono::Utc::now().timestamp_millis();
    |                       ^^^^^^ use of unresolved module or unlinked crate `chrono`
    |
    = help: if you wanted to use a crate named `chrono`, use `cargo add chrono` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `chrono`
   --> src\screen_recording\recorder.rs:465:25
    |
465 |         let timestamp = chrono::Local::now().format("%Y%m%d_%H%M%S");
    |                         ^^^^^^ use of unresolved module or unlinked crate `chrono`
    |
    = help: if you wanted to use a crate named `chrono`, use `cargo add chrono` to add it to your `Cargo.toml`
help: there is an enum variant `tauri::ipc::Origin::Local`; try using the variant's enum
    |
465 -         let timestamp = chrono::Local::now().format("%Y%m%d_%H%M%S");
465 +         let timestamp = tauri::ipc::Origin::now().format("%Y%m%d_%H%M%S");
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `chrono`
   --> src\screen_recording\recorder.rs:624:24
    |
624 |         let end_time = chrono::Utc::now().timestamp_millis();
    |                        ^^^^^^ use of unresolved module or unlinked crate `chrono`
    |
    = help: if you wanted to use a crate named `chrono`, use `cargo add chrono` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `chrono`
   --> src\screenshot\capture.rs:240:28
    |
240 |                 timestamp: chrono::Utc::now().timestamp_millis(),
    |                            ^^^^^^ use of unresolved module or unlinked crate `chrono`
    |
    = help: if you wanted to use a crate named `chrono`, use `cargo add chrono` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `png`
   --> src\screenshot\capture.rs:274:31
    |
274 |             let mut encoder = png::Encoder::new(&mut png_data, width, height);
    |                               ^^^ use of unresolved module or unlinked crate `png`
    |
    = help: if you wanted to use a crate named `png`, use `cargo add png` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `png`
   --> src\screenshot\capture.rs:275:31
    |
275 |             encoder.set_color(png::ColorType::Rgba);
    |                               ^^^ use of unresolved module or unlinked crate `png`
    |
    = help: if you wanted to use a crate named `png`, use `cargo add png` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `png`
   --> src\screenshot\capture.rs:276:31
    |
276 |             encoder.set_depth(png::BitDepth::Eight);
    |                               ^^^ use of unresolved module or unlinked crate `png`
    |
    = help: if you wanted to use a crate named `png`, use `cargo add png` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `png`
   --> src\screenshot\capture.rs:277:37
    |
277 |             encoder.set_compression(png::Compression::Fast);
    |                                     ^^^ use of unresolved module or unlinked crate `png`
    |
    = help: if you wanted to use a crate named `png`, use `cargo add png` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `png`
  --> src\screenshot\ocr.rs:71:23
   |
71 |         let decoder = png::Decoder::new(Cursor::new(&image_data));
   |                       ^^^ use of unresolved module or unlinked crate `png`
   |
   = help: if you wanted to use a crate named `png`, use `cargo add png` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `png`
  --> src\screenshot\windows_ocr.rs:79:23
   |
79 |         let decoder = png::Decoder::new(std::io::Cursor::new(image_data));
   |                       ^^^ use of unresolved module or unlinked crate `png`
   |
   = help: if you wanted to use a crate named `png`, use `cargo add png` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `uuid`
  --> src\screenshot\screenshot_history.rs:44:17
   |
44 |             id: uuid::Uuid::new_v4().to_string(),
   |                 ^^^^ use of unresolved module or unlinked crate `uuid`
   |
   = help: if you wanted to use a crate named `uuid`, use `cargo add uuid` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `chrono`
  --> src\screenshot\screenshot_history.rs:45:24
   |
45 |             timestamp: chrono::Utc::now().timestamp_millis(),
   |                        ^^^^^^ use of unresolved module or unlinked crate `chrono`
   |
   = help: if you wanted to use a crate named `chrono`, use `cargo add chrono` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
   --> src\screenshot\mod.rs:133:13
    |
133 |             tokio::time::sleep(tokio::time::Duration::from_millis(config.delay_ms)).await;
    |             ^^^^^ use of unresolved module or unlinked crate `tokio`
    |
    = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `png`
   --> src\screenshot\mod.rs:204:23
    |
204 |         let decoder = png::Decoder::new(std::io::Cursor::new(image_data));
    |                       ^^^ use of unresolved module or unlinked crate `png`
    |
    = help: if you wanted to use a crate named `png`, use `cargo add png` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `rdev`
  --> src\selection\mouse_hook.rs:95:44
   |
95 |                     EventType::ButtonPress(rdev::Button::Left) => {
   |                                            ^^^^ use of unresolved module or unlinked crate `rdev`
   |
   = help: if you wanted to use a crate named `rdev`, use `cargo add rdev` to add it to your `Cargo.toml`
help: there is an enum variant `crate::context::UiElementType::Button`; try using the variant's enum
   |
95 -                     EventType::ButtonPress(rdev::Button::Left) => {
95 +                     EventType::ButtonPress(crate::context::UiElementType::Left) => {
   |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `rdev`
   --> src\selection\mouse_hook.rs:100:46
    |
100 |                     EventType::ButtonRelease(rdev::Button::Left) => {
    |                                              ^^^^ use of unresolved module or unlinked crate `rdev`
    |
    = help: if you wanted to use a crate named `rdev`, use `cargo add rdev` to add it to your `Cargo.toml`
help: there is an enum variant `crate::context::UiElementType::Button`; try using the variant's enum
    |
100 -                     EventType::ButtonRelease(rdev::Button::Left) => {
100 +                     EventType::ButtonRelease(crate::context::UiElementType::Left) => {
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `mouse_position`
   --> src\selection\mouse_hook.rs:213:11
    |
213 |     match mouse_position::mouse_position::Mouse::get_mouse_position() {
    |           ^^^^^^^^^^^^^^ use of unresolved module or unlinked crate `mouse_position`
    |
    = help: if you wanted to use a crate named `mouse_position`, use `cargo add mouse_position` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `mouse_position`
   --> src\selection\mouse_hook.rs:214:9
    |
214 |         mouse_position::mouse_position::Mouse::Position { x, y } => (x as f64, y as f64),
    |         ^^^^^^^^^^^^^^ use of unresolved module or unlinked crate `mouse_position`
    |
    = help: if you wanted to use a crate named `mouse_position`, use `cargo add mouse_position` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `mouse_position`
   --> src\selection\mouse_hook.rs:215:9
    |
215 |         mouse_position::mouse_position::Mouse::Error => (0.0, 0.0),
    |         ^^^^^^^^^^^^^^ use of unresolved module or unlinked crate `mouse_position`
    |
    = help: if you wanted to use a crate named `mouse_position`, use `cargo add mouse_position` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `chrono`
  --> src\selection\history.rs:48:24
   |
48 |             timestamp: chrono::Utc::now().timestamp_millis(),
   |                        ^^^^^^ use of unresolved module or unlinked crate `chrono`
   |
   = help: if you wanted to use a crate named `chrono`, use `cargo add chrono` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `uuid`
  --> src\selection\clipboard_history.rs:63:17
   |
63 |             id: uuid::Uuid::new_v4().to_string(),
   |                 ^^^^ use of unresolved module or unlinked crate `uuid`
   |
   = help: if you wanted to use a crate named `uuid`, use `cargo add uuid` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `chrono`
  --> src\selection\clipboard_history.rs:69:24
   |
69 |             timestamp: chrono::Utc::now().timestamp_millis(),
   |                        ^^^^^^ use of unresolved module or unlinked crate `chrono`
   |
   = help: if you wanted to use a crate named `chrono`, use `cargo add chrono` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `uuid`
  --> src\selection\clipboard_history.rs:86:17
   |
86 |             id: uuid::Uuid::new_v4().to_string(),
   |                 ^^^^ use of unresolved module or unlinked crate `uuid`
   |
   = help: if you wanted to use a crate named `uuid`, use `cargo add uuid` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `chrono`
  --> src\selection\clipboard_history.rs:92:24
   |
92 |             timestamp: chrono::Utc::now().timestamp_millis(),
   |                        ^^^^^^ use of unresolved module or unlinked crate `chrono`
   |
   = help: if you wanted to use a crate named `chrono`, use `cargo add chrono` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `uuid`
   --> src\selection\clipboard_history.rs:103:17
    |
103 |             id: uuid::Uuid::new_v4().to_string(),
    |                 ^^^^ use of unresolved module or unlinked crate `uuid`
    |
    = help: if you wanted to use a crate named `uuid`, use `cargo add uuid` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `chrono`
   --> src\selection\clipboard_history.rs:109:24
    |
109 |             timestamp: chrono::Utc::now().timestamp_millis(),
    |                        ^^^^^^ use of unresolved module or unlinked crate `chrono`
    |
    = help: if you wanted to use a crate named `chrono`, use `cargo add chrono` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `uuid`
   --> src\selection\clipboard_history.rs:126:17
    |
126 |             id: uuid::Uuid::new_v4().to_string(),
    |                 ^^^^ use of unresolved module or unlinked crate `uuid`
    |
    = help: if you wanted to use a crate named `uuid`, use `cargo add uuid` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `chrono`
   --> src\selection\clipboard_history.rs:132:24
    |
132 |             timestamp: chrono::Utc::now().timestamp_millis(),
    |                        ^^^^^^ use of unresolved module or unlinked crate `chrono`
    |
    = help: if you wanted to use a crate named `chrono`, use `cargo add chrono` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `base64`
   --> src\selection\clipboard_history.rs:357:30
    |
357 |                 let base64 = base64::Engine::encode(
    |                              ^^^^^^ use of unresolved module or unlinked crate `base64`
    |
    = help: if you wanted to use a crate named `base64`, use `cargo add base64` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `base64`
   --> src\selection\clipboard_history.rs:358:22
    |
358 |                     &base64::engine::general_purpose::STANDARD,
    |                      ^^^^^^ use of unresolved module or unlinked crate `base64`
    |
    = help: if you wanted to use a crate named `base64`, use `cargo add base64` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `base64`
   --> src\selection\clipboard_history.rs:388:34
    |
388 |                     let _bytes = base64::Engine::decode(
    |                                  ^^^^^^ use of unresolved module or unlinked crate `base64`
    |
    = help: if you wanted to use a crate named `base64`, use `cargo add base64` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `base64`
   --> src\selection\clipboard_history.rs:389:26
    |
389 |                         &base64::engine::general_purpose::STANDARD,
    |                          ^^^^^^ use of unresolved module or unlinked crate `base64`
    |
    = help: if you wanted to use a crate named `base64`, use `cargo add base64` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
   --> src\selection\mod.rs:319:9
    |
319 |         tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
    |         ^^^^^ use of unresolved module or unlinked crate `tokio`
    |
    = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `chrono`
   --> src\selection\mod.rs:415:24
    |
415 |             timestamp: chrono::Utc::now().timestamp_millis(),
    |                        ^^^^^^ use of unresolved module or unlinked crate `chrono`
    |
    = help: if you wanted to use a crate named `chrono`, use `cargo add chrono` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `mouse_position`
   --> src\selection\mod.rs:432:11
    |
432 |     match mouse_position::mouse_position::Mouse::get_mouse_position() {
    |           ^^^^^^^^^^^^^^ use of unresolved module or unlinked crate `mouse_position`
    |
    = help: if you wanted to use a crate named `mouse_position`, use `cargo add mouse_position` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `mouse_position`
   --> src\selection\mod.rs:433:9
    |
433 |         mouse_position::mouse_position::Mouse::Position { x, y } => (x as f64, y as f64),
    |         ^^^^^^^^^^^^^^ use of unresolved module or unlinked crate `mouse_position`
    |
    = help: if you wanted to use a crate named `mouse_position`, use `cargo add mouse_position` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `mouse_position`
   --> src\selection\mod.rs:434:9
    |
434 |         mouse_position::mouse_position::Mouse::Error => (0.0, 0.0),
    |         ^^^^^^^^^^^^^^ use of unresolved module or unlinked crate `mouse_position`
    |
    = help: if you wanted to use a crate named `mouse_position`, use `cargo add mouse_position` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
   --> src\tray.rs:163:21
    |
163 |                     tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
    |                     ^^^^^ use of unresolved module or unlinked crate `tokio`
    |
    = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
   --> src\lib.rs:171:17
    |
171 |                 tokio::time::sleep(tokio::time::Duration::from_secs(2)).await;
    |                 ^^^^^ use of unresolved module or unlinked crate `tokio`
    |
    = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
   --> src\awareness\mod.rs:120:36
    |
120 |                 tokio::time::sleep(tokio::time::Duration::from_secs(60)).await;
    |                                    ^^^^^ use of unresolved module or unlinked crate `tokio`
    |
    = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`
help: consider importing this struct
    |
19  + use std::time::Duration;
    |
help: if you import `Duration`, refer to it directly
    |
120 -                 tokio::time::sleep(tokio::time::Duration::from_secs(60)).await;
120 +                 tokio::time::sleep(Duration::from_secs(60)).await;
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `arboard`
  --> src\commands\clipboard.rs:18:25
   |
18 |     let mut clipboard = arboard::Clipboard::new().map_err(|e| e.to_string())?;
   |                         ^^^^^^^ use of unresolved module or unlinked crate `arboard`
   |
   = help: if you wanted to use a crate named `arboard`, use `cargo add arboard` to add it to your `Cargo.toml`
help: consider importing this struct
   |
3  + use tauri_plugin_clipboard_manager::Clipboard;
   |
help: if you import `Clipboard`, refer to it directly
   |
18 -     let mut clipboard = arboard::Clipboard::new().map_err(|e| e.to_string())?;
18 +     let mut clipboard = Clipboard::new().map_err(|e| e.to_string())?;
   |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `arboard`
  --> src\commands\clipboard.rs:67:25
   |
67 |     let mut clipboard = arboard::Clipboard::new().map_err(|e| e.to_string())?;
   |                         ^^^^^^^ use of unresolved module or unlinked crate `arboard`
   |
   = help: if you wanted to use a crate named `arboard`, use `cargo add arboard` to add it to your `Cargo.toml`
help: consider importing this struct
   |
3  + use tauri_plugin_clipboard_manager::Clipboard;
   |
help: if you import `Clipboard`, refer to it directly
   |
67 -     let mut clipboard = arboard::Clipboard::new().map_err(|e| e.to_string())?;
67 +     let mut clipboard = Clipboard::new().map_err(|e| e.to_string())?;
   |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `arboard`
  --> src\commands\clipboard.rs:77:25
   |
77 |     let mut clipboard = arboard::Clipboard::new().map_err(|e| e.to_string())?;
   |                         ^^^^^^^ use of unresolved module or unlinked crate `arboard`
   |
   = help: if you wanted to use a crate named `arboard`, use `cargo add arboard` to add it to your `Cargo.toml`
help: consider importing this struct
   |
3  + use tauri_plugin_clipboard_manager::Clipboard;
   |
help: if you import `Clipboard`, refer to it directly
   |
77 -     let mut clipboard = arboard::Clipboard::new().map_err(|e| e.to_string())?;
77 +     let mut clipboard = Clipboard::new().map_err(|e| e.to_string())?;
   |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `arboard`
  --> src\commands\clipboard.rs:84:25
   |
84 |     let mut clipboard = arboard::Clipboard::new().map_err(|e| e.to_string())?;
   |                         ^^^^^^^ use of unresolved module or unlinked crate `arboard`
   |
   = help: if you wanted to use a crate named `arboard`, use `cargo add arboard` to add it to your `Cargo.toml`
help: consider importing this struct
   |
3  + use tauri_plugin_clipboard_manager::Clipboard;
   |
help: if you import `Clipboard`, refer to it directly
   |
84 -     let mut clipboard = arboard::Clipboard::new().map_err(|e| e.to_string())?;
84 +     let mut clipboard = Clipboard::new().map_err(|e| e.to_string())?;
   |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
   --> src\commands\environment.rs:221:24
    |
221 |     tokio::time::sleep(tokio::time::Duration::from_secs(2)).await;
    |                        ^^^^^ use of unresolved module or unlinked crate `tokio`
    |
    = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`
help: consider importing this struct
    |
9   + use std::time::Duration;
    |
help: if you import `Duration`, refer to it directly
    |
221 -     tokio::time::sleep(tokio::time::Duration::from_secs(2)).await;
221 +     tokio::time::sleep(Duration::from_secs(2)).await;
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
   --> src\commands\selection.rs:595:28
    |
595 |         tokio::time::sleep(tokio::time::Duration::from_millis(50)).await;
    |                            ^^^^^ use of unresolved module or unlinked crate `tokio`
    |
    = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`
help: consider importing this struct
    |
5   + use std::time::Duration;
    |
help: if you import `Duration`, refer to it directly
    |
595 -         tokio::time::sleep(tokio::time::Duration::from_millis(50)).await;
595 +         tokio::time::sleep(Duration::from_millis(50)).await;
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `parking_lot`
  --> src\mcp\config.rs:73:21
   |
73 |             config: parking_lot::RwLock::new(McpConfig::new()),
   |                     ^^^^^^^^^^^ use of unresolved module or unlinked crate `parking_lot`
   |
   = help: if you wanted to use a crate named `parking_lot`, use `cargo add parking_lot` to add it to your `Cargo.toml`
help: consider importing one of these structs
   |
5  + use std::sync::RwLock;
   |
5  + use tauri::async_runtime::RwLock;
   |
help: if you import `RwLock`, refer to it directly
   |
73 -             config: parking_lot::RwLock::new(McpConfig::new()),
73 +             config: RwLock::new(McpConfig::new()),
   |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
  --> src\mcp\config.rs:89:23
   |
89 |         let content = tokio::fs::read_to_string(&self.config_path)
   |                       ^^^^^ use of unresolved module or unlinked crate `tokio`
   |
   = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`
help: consider importing this module
   |
5  + use std::fs;
   |
help: if you import `fs`, refer to it directly
   |
89 -         let content = tokio::fs::read_to_string(&self.config_path)
89 +         let content = fs::read_to_string(&self.config_path)
   |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
   --> src\mcp\config.rs:110:13
    |
110 |             tokio::fs::create_dir_all(parent).await.map_err(|e| {
    |             ^^^^^ use of unresolved module or unlinked crate `tokio`
    |
    = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`
help: consider importing this module
    |
5   + use std::fs;
    |
help: if you import `fs`, refer to it directly
    |
110 -             tokio::fs::create_dir_all(parent).await.map_err(|e| {
110 +             fs::create_dir_all(parent).await.map_err(|e| {
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
   --> src\mcp\config.rs:118:9
    |
118 |         tokio::fs::write(&self.config_path, content)
    |         ^^^^^ use of unresolved module or unlinked crate `tokio`
    |
    = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`
help: consider importing this module
    |
5   + use std::fs;
    |
help: if you import `fs`, refer to it directly
    |
118 -         tokio::fs::write(&self.config_path, content)
118 +         fs::write(&self.config_path, content)
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
   --> src\sandbox\docker.rs:171:9
    |
171 |         tokio::fs::write(&code_path, &request.code).await?;
    |         ^^^^^ use of unresolved module or unlinked crate `tokio`
    |
    = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`
help: consider importing this module
    |
5   + use std::fs;
    |
help: if you import `fs`, refer to it directly
    |
171 -         tokio::fs::write(&code_path, &request.code).await?;
171 +         fs::write(&code_path, &request.code).await?;
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
   --> src\sandbox\docker.rs:177:17
    |
177 |                 tokio::fs::create_dir_all(parent).await?;
    |                 ^^^^^ use of unresolved module or unlinked crate `tokio`
    |
    = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`
help: consider importing this module
    |
5   + use std::fs;
    |
help: if you import `fs`, refer to it directly
    |
177 -                 tokio::fs::create_dir_all(parent).await?;
177 +                 fs::create_dir_all(parent).await?;
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
   --> src\sandbox\docker.rs:179:13
    |
179 |             tokio::fs::write(&file_path, content).await?;
    |             ^^^^^ use of unresolved module or unlinked crate `tokio`
    |
    = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`
help: consider importing this module
    |
5   + use std::fs;
    |
help: if you import `fs`, refer to it directly
    |
179 -             tokio::fs::write(&file_path, content).await?;
179 +             fs::write(&file_path, content).await?;
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
   --> src\sandbox\native.rs:182:9
    |
182 |         tokio::fs::write(&code_path, &request.code).await?;
    |         ^^^^^ use of unresolved module or unlinked crate `tokio`
    |
    = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`
help: consider importing this module
    |
5   + use std::fs;
    |
help: if you import `fs`, refer to it directly
    |
182 -         tokio::fs::write(&code_path, &request.code).await?;
182 +         fs::write(&code_path, &request.code).await?;
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
   --> src\sandbox\native.rs:188:17
    |
188 |                 tokio::fs::create_dir_all(parent).await?;
    |                 ^^^^^ use of unresolved module or unlinked crate `tokio`
    |
    = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`
help: consider importing this module
    |
5   + use std::fs;
    |
help: if you import `fs`, refer to it directly
    |
188 -                 tokio::fs::create_dir_all(parent).await?;
188 +                 fs::create_dir_all(parent).await?;
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
   --> src\sandbox\native.rs:190:13
    |
190 |             tokio::fs::write(&file_path, content).await?;
    |             ^^^^^ use of unresolved module or unlinked crate `tokio`
    |
    = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`
help: consider importing this module
    |
5   + use std::fs;
    |
help: if you import `fs`, refer to it directly
    |
190 -             tokio::fs::write(&file_path, content).await?;
190 +             fs::write(&file_path, content).await?;
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
   --> src\sandbox\podman.rs:157:9
    |
157 |         tokio::fs::write(&code_path, &request.code).await?;
    |         ^^^^^ use of unresolved module or unlinked crate `tokio`
    |
    = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`
help: consider importing this module
    |
5   + use std::fs;
    |
help: if you import `fs`, refer to it directly
    |
157 -         tokio::fs::write(&code_path, &request.code).await?;
157 +         fs::write(&code_path, &request.code).await?;
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
   --> src\sandbox\podman.rs:162:17
    |
162 |                 tokio::fs::create_dir_all(parent).await?;
    |                 ^^^^^ use of unresolved module or unlinked crate `tokio`
    |
    = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`
help: consider importing this module
    |
5   + use std::fs;
    |
help: if you import `fs`, refer to it directly
    |
162 -                 tokio::fs::create_dir_all(parent).await?;
162 +                 fs::create_dir_all(parent).await?;
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
   --> src\sandbox\podman.rs:164:13
    |
164 |             tokio::fs::write(&file_path, content).await?;
    |             ^^^^^ use of unresolved module or unlinked crate `tokio`
    |
    = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`
help: consider importing this module
    |
5   + use std::fs;
    |
help: if you import `fs`, refer to it directly
    |
164 -             tokio::fs::write(&file_path, content).await?;
164 +             fs::write(&file_path, content).await?;
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
   --> src\sandbox\mod.rs:155:27
    |
155 |             let content = tokio::fs::read_to_string(&config_path)
    |                           ^^^^^ use of unresolved module or unlinked crate `tokio`
    |
    = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`
help: consider importing this module
    |
16  + use std::fs;
    |
help: if you import `fs`, refer to it directly
    |
155 -             let content = tokio::fs::read_to_string(&config_path)
155 +             let content = fs::read_to_string(&config_path)
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
   --> src\sandbox\mod.rs:192:13
    |
192 |             tokio::fs::create_dir_all(parent)
    |             ^^^^^ use of unresolved module or unlinked crate `tokio`
    |
    = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`
help: consider importing this module
    |
16  + use std::fs;
    |
help: if you import `fs`, refer to it directly
    |
192 -             tokio::fs::create_dir_all(parent)
192 +             fs::create_dir_all(parent)
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
   --> src\sandbox\mod.rs:197:9
    |
197 |         tokio::fs::write(&self.config_path, content)
    |         ^^^^^ use of unresolved module or unlinked crate `tokio`
    |
    = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`
help: consider importing this module
    |
16  + use std::fs;
    |
help: if you import `fs`, refer to it directly
    |
197 -         tokio::fs::write(&self.config_path, content)
197 +         fs::write(&self.config_path, content)
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
   --> src\screen_recording\recorder.rs:131:36
    |
131 |                 tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
    |                                    ^^^^^ use of unresolved module or unlinked crate `tokio`
    |
    = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`
help: consider importing this struct
    |
5   + use std::time::Duration;
    |
help: if you import `Duration`, refer to it directly
    |
131 -                 tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
131 +                 tokio::time::sleep(Duration::from_secs(1)).await;
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
   --> src\screen_recording\recorder.rs:181:36
    |
181 |                 tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
    |                                    ^^^^^ use of unresolved module or unlinked crate `tokio`
    |
    = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`
help: consider importing this struct
    |
5   + use std::time::Duration;
    |
help: if you import `Duration`, refer to it directly
    |
181 -                 tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
181 +                 tokio::time::sleep(Duration::from_secs(1)).await;
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
   --> src\screen_recording\recorder.rs:226:36
    |
226 |                 tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
    |                                    ^^^^^ use of unresolved module or unlinked crate `tokio`
    |
    = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`
help: consider importing this struct
    |
5   + use std::time::Duration;
    |
help: if you import `Duration`, refer to it directly
    |
226 -                 tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
226 +                 tokio::time::sleep(Duration::from_secs(1)).await;
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `parking_lot`
   --> src\screenshot\mod.rs:111:41
    |
111 |             config: std::sync::Arc::new(parking_lot::RwLock::new(ScreenshotConfig::default())),
    |                                         ^^^^^^^^^^^ use of unresolved module or unlinked crate `parking_lot`
    |
    = help: if you wanted to use a crate named `parking_lot`, use `cargo add parking_lot` to add it to your `Cargo.toml`
help: consider importing one of these structs
    |
21  + use std::sync::RwLock;
    |
21  + use tauri::async_runtime::RwLock;
    |
help: if you import `RwLock`, refer to it directly
    |
111 -             config: std::sync::Arc::new(parking_lot::RwLock::new(ScreenshotConfig::default())),
111 +             config: std::sync::Arc::new(RwLock::new(ScreenshotConfig::default())),
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
   --> src\screenshot\mod.rs:133:32
    |
133 |             tokio::time::sleep(tokio::time::Duration::from_millis(config.delay_ms)).await;
    |                                ^^^^^ use of unresolved module or unlinked crate `tokio`
    |
    = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`
help: consider importing this struct
    |
21  + use std::time::Duration;
    |
help: if you import `Duration`, refer to it directly
    |
133 -             tokio::time::sleep(tokio::time::Duration::from_millis(config.delay_ms)).await;
133 +             tokio::time::sleep(Duration::from_millis(config.delay_ms)).await;
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
   --> src\selection\mod.rs:319:28
    |
319 |         tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
    |                            ^^^^^ use of unresolved module or unlinked crate `tokio`
    |
    = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`
help: consider importing this struct
    |
17  + use std::time::Duration;
    |
help: if you import `Duration`, refer to it directly
    |
319 -         tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
319 +         tokio::time::sleep(Duration::from_millis(100)).await;
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
   --> src\tray.rs:163:40
    |
163 |                     tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
    |                                        ^^^^^ use of unresolved module or unlinked crate `tokio`
    |
    = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`
help: consider importing this struct
    |
5   + use std::time::Duration;
    |
help: if you import `Duration`, refer to it directly
    |
163 -                     tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
163 +                     tokio::time::sleep(Duration::from_millis(100)).await;
    |

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
   --> src\lib.rs:171:36
    |
171 |                 tokio::time::sleep(tokio::time::Duration::from_secs(2)).await;
    |                                    ^^^^^ use of unresolved module or unlinked crate `tokio`
    |
    = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`
help: consider importing this struct
    |
16  + use std::time::Duration;
    |
help: if you import `Duration`, refer to it directly
    |
171 -                 tokio::time::sleep(tokio::time::Duration::from_secs(2)).await;
171 +                 tokio::time::sleep(Duration::from_secs(2)).await;
    |

error[E0038]: the trait `Transport` is not dyn compatible
  --> src\mcp\client.rs:30:20
   |
30 |     transport: Arc<dyn Transport>,
   |                    ^^^^^^^^^^^^^ `Transport` is not dyn compatible
   |
note: for a trait to be dyn compatible it needs to allow building a vtable
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
  --> src\mcp\transport\mod.rs:16:14
   |
14 | pub trait Transport: Send + Sync {
   |           --------- this trait is not dyn compatible...
15 |     /// Send a message through the transport
16 |     async fn send(&self, message: &str) -> McpResult<()>;
   |              ^^^^ ...because method `send` is `async`
...
19 |     async fn receive(&self) -> McpResult<String>;
   |              ^^^^^^^ ...because method `receive` is `async`
...
22 |     async fn close(&self) -> McpResult<()>;
   |              ^^^^^ ...because method `close` is `async`
   = help: consider moving `close` to another trait
   = help: consider moving `send` to another trait
   = help: consider moving `receive` to another trait
   = help: the following types implement `Transport`:
             mcp::transport::sse::SseTransport
             mcp::transport::stdio::StdioTransport
           consider defining an enum where each variant holds one of these types,
           implementing `Transport` for this new enum and using it instead

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `open`
   --> src\commands\environment.rs:537:5
    |
537 |     open::that(url).map_err(|e| e.to_string())
    |     ^^^^ use of unresolved module or unlinked crate `open`
    |
    = help: if you wanted to use a crate named `open`, use `cargo add open` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `dirs`
   --> src\commands\environment.rs:710:9
    |
710 |         dirs::home_dir()
    |         ^^^^ use of unresolved module or unlinked crate `dirs`
    |
    = help: if you wanted to use a crate named `dirs`, use `cargo add dirs` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `dirs`
    --> src\commands\environment.rs:1011:9
     |
1011 |         dirs::home_dir()
     |         ^^^^ use of unresolved module or unlinked crate `dirs`
     |
     = help: if you wanted to use a crate named `dirs`, use `cargo add dirs` to add it to your `Cargo.toml`

error[E0599]: `McpError` doesn't implement `std::fmt::Display`
    --> src\commands\mcp.rs:33:24
     |
33   |         .map_err(|e| e.to_string())
     |                        ^^^^^^^^^ method cannot be called on `McpError` due to unsatisfied trait bounds
     |
    ::: src\mcp\error.rs:13:1
     |
13   | pub enum McpError {
     | ----------------- method `to_string` not found for this enum because it doesn't satisfy `McpError: ToString` or `McpError: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `McpError: std::fmt::Display`
             which is required by `McpError: ToString`
note: the trait `std::fmt::Display` must be implemented
    --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\fmt\mod.rs:1003:1
     |
1003 | pub trait Display: PointeeSized {
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following trait defines an item `to_string`, perhaps you need to implement it:
             candidate #1: `ToString`

error[E0599]: `McpError` doesn't implement `std::fmt::Display`
    --> src\commands\mcp.rs:42:52
     |
42   |     manager.remove_server(&id).await.map_err(|e| e.to_string())
     |                                                    ^^^^^^^^^ method cannot be called on `McpError` due to unsatisfied trait bounds
     |
    ::: src\mcp\error.rs:13:1
     |
13   | pub enum McpError {
     | ----------------- method `to_string` not found for this enum because it doesn't satisfy `McpError: ToString` or `McpError: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `McpError: std::fmt::Display`
             which is required by `McpError: ToString`
note: the trait `std::fmt::Display` must be implemented
    --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\fmt\mod.rs:1003:1
     |
1003 | pub trait Display: PointeeSized {
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following trait defines an item `to_string`, perhaps you need to implement it:
             candidate #1: `ToString`

error[E0599]: `McpError` doesn't implement `std::fmt::Display`
    --> src\commands\mcp.rs:55:24
     |
55   |         .map_err(|e| e.to_string())
     |                        ^^^^^^^^^ method cannot be called on `McpError` due to unsatisfied trait bounds
     |
    ::: src\mcp\error.rs:13:1
     |
13   | pub enum McpError {
     | ----------------- method `to_string` not found for this enum because it doesn't satisfy `McpError: ToString` or `McpError: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `McpError: std::fmt::Display`
             which is required by `McpError: ToString`
note: the trait `std::fmt::Display` must be implemented
    --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\fmt\mod.rs:1003:1
     |
1003 | pub trait Display: PointeeSized {
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following trait defines an item `to_string`, perhaps you need to implement it:
             candidate #1: `ToString`

error[E0599]: `McpError` doesn't implement `std::fmt::Display`
    --> src\commands\mcp.rs:67:24
     |
67   |         .map_err(|e| e.to_string())
     |                        ^^^^^^^^^ method cannot be called on `McpError` due to unsatisfied trait bounds
     |
    ::: src\mcp\error.rs:13:1
     |
13   | pub enum McpError {
     | ----------------- method `to_string` not found for this enum because it doesn't satisfy `McpError: ToString` or `McpError: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `McpError: std::fmt::Display`
             which is required by `McpError: ToString`
note: the trait `std::fmt::Display` must be implemented
    --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\fmt\mod.rs:1003:1
     |
1003 | pub trait Display: PointeeSized {
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following trait defines an item `to_string`, perhaps you need to implement it:
             candidate #1: `ToString`

error[E0599]: `McpError` doesn't implement `std::fmt::Display`
    --> src\commands\mcp.rs:79:24
     |
79   |         .map_err(|e| e.to_string())
     |                        ^^^^^^^^^ method cannot be called on `McpError` due to unsatisfied trait bounds
     |
    ::: src\mcp\error.rs:13:1
     |
13   | pub enum McpError {
     | ----------------- method `to_string` not found for this enum because it doesn't satisfy `McpError: ToString` or `McpError: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `McpError: std::fmt::Display`
             which is required by `McpError: ToString`
note: the trait `std::fmt::Display` must be implemented
    --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\fmt\mod.rs:1003:1
     |
1003 | pub trait Display: PointeeSized {
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following trait defines an item `to_string`, perhaps you need to implement it:
             candidate #1: `ToString`

error[E0599]: `McpError` doesn't implement `std::fmt::Display`
    --> src\commands\mcp.rs:93:24
     |
93   |         .map_err(|e| e.to_string())
     |                        ^^^^^^^^^ method cannot be called on `McpError` due to unsatisfied trait bounds
     |
    ::: src\mcp\error.rs:13:1
     |
13   | pub enum McpError {
     | ----------------- method `to_string` not found for this enum because it doesn't satisfy `McpError: ToString` or `McpError: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `McpError: std::fmt::Display`
             which is required by `McpError: ToString`
note: the trait `std::fmt::Display` must be implemented
    --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\fmt\mod.rs:1003:1
     |
1003 | pub trait Display: PointeeSized {
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following trait defines an item `to_string`, perhaps you need to implement it:
             candidate #1: `ToString`

error[E0599]: `McpError` doesn't implement `std::fmt::Display`
    --> src\commands\mcp.rs:114:24
     |
114  |         .map_err(|e| e.to_string())
     |                        ^^^^^^^^^ method cannot be called on `McpError` due to unsatisfied trait bounds
     |
    ::: src\mcp\error.rs:13:1
     |
13   | pub enum McpError {
     | ----------------- method `to_string` not found for this enum because it doesn't satisfy `McpError: ToString` or `McpError: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `McpError: std::fmt::Display`
             which is required by `McpError: ToString`
note: the trait `std::fmt::Display` must be implemented
    --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\fmt\mod.rs:1003:1
     |
1003 | pub trait Display: PointeeSized {
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following trait defines an item `to_string`, perhaps you need to implement it:
             candidate #1: `ToString`

error[E0599]: `McpError` doesn't implement `std::fmt::Display`
    --> src\commands\mcp.rs:128:24
     |
128  |         .map_err(|e| e.to_string())
     |                        ^^^^^^^^^ method cannot be called on `McpError` due to unsatisfied trait bounds
     |
    ::: src\mcp\error.rs:13:1
     |
13   | pub enum McpError {
     | ----------------- method `to_string` not found for this enum because it doesn't satisfy `McpError: ToString` or `McpError: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `McpError: std::fmt::Display`
             which is required by `McpError: ToString`
note: the trait `std::fmt::Display` must be implemented
    --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\fmt\mod.rs:1003:1
     |
1003 | pub trait Display: PointeeSized {
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following trait defines an item `to_string`, perhaps you need to implement it:
             candidate #1: `ToString`

error[E0599]: `McpError` doesn't implement `std::fmt::Display`
    --> src\commands\mcp.rs:134:49
     |
134  |     manager.reload_config().await.map_err(|e| e.to_string())
     |                                                 ^^^^^^^^^ method cannot be called on `McpError` due to unsatisfied trait bounds
     |
    ::: src\mcp\error.rs:13:1
     |
13   | pub enum McpError {
     | ----------------- method `to_string` not found for this enum because it doesn't satisfy `McpError: ToString` or `McpError: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `McpError: std::fmt::Display`
             which is required by `McpError: ToString`
note: the trait `std::fmt::Display` must be implemented
    --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\fmt\mod.rs:1003:1
     |
1003 | pub trait Display: PointeeSized {
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following trait defines an item `to_string`, perhaps you need to implement it:
             candidate #1: `ToString`

error[E0599]: `McpError` doesn't implement `std::fmt::Display`
    --> src\commands\mcp.rs:243:24
     |
243  |         .map_err(|e| e.to_string())
     |                        ^^^^^^^^^ method cannot be called on `McpError` due to unsatisfied trait bounds
     |
    ::: src\mcp\error.rs:13:1
     |
13   | pub enum McpError {
     | ----------------- method `to_string` not found for this enum because it doesn't satisfy `McpError: ToString` or `McpError: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `McpError: std::fmt::Display`
             which is required by `McpError: ToString`
note: the trait `std::fmt::Display` must be implemented
    --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\fmt\mod.rs:1003:1
     |
1003 | pub trait Display: PointeeSized {
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following trait defines an item `to_string`, perhaps you need to implement it:
             candidate #1: `ToString`

error[E0277]: the size for values of type `[_]` cannot be known at compilation time
   --> src\commands\ollama.rs:218:16
    |
218 |             Ok(bytes) => {
    |                ^^^^^ doesn't have a size known at compile-time
    |
    = help: the trait `Sized` is not implemented for `[_]`
    = note: all local variables must have a statically known size

error[E0277]: the size for values of type `[_]` cannot be known at compilation time
   --> src\commands\ollama.rs:218:13
    |
218 |             Ok(bytes) => {
    |             ^^^^^^^^^ doesn't have a size known at compile-time
    |
    = help: the trait `Sized` is not implemented for `[_]`
note: required by a bound in `std::prelude::v1::Ok`
   --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\result.rs:548:17
    |
548 | pub enum Result<T, E> {
    |                 ^ required by this bound in `std::prelude::v1::Ok`
...
552 |     Ok(#[stable(feature = "rust1", since = "1.0.0")] T),
    |     -- required by a bound in this tuple variant

error[E0277]: the size for values of type `[_]` cannot be known at compilation time
   --> src\commands\ollama.rs:247:13
    |
247 |             Err(e) => {
    |             ^^^^^^ doesn't have a size known at compile-time
    |
    = help: the trait `Sized` is not implemented for `[_]`
note: required by a bound in `std::prelude::v1::Err`
   --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\result.rs:548:17
    |
548 | pub enum Result<T, E> {
    |                 ^ required by this bound in `std::prelude::v1::Err`
...
557 |     Err(#[stable(feature = "rust1", since = "1.0.0")] E),
    |     --- required by a bound in this tuple variant

error[E0277]: the size for values of type `[_]` cannot be known at compilation time
   --> src\commands\ollama.rs:216:43
    |
216 |     while let Some(chunk) = stream.next().await {
    |                                           ^^^^^ doesn't have a size known at compile-time
    |
    = help: the trait `Sized` is not implemented for `[_]`
note: required by an implicit `Sized` bound in `Result`
   --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\result.rs:548:17
    |
548 | pub enum Result<T, E> {
    |                 ^ required by the implicit `Sized` requirement on this type parameter in `Result`

error[E0599]: `SandboxError` doesn't implement `std::fmt::Display`
    --> src\commands\sandbox.rs:84:24
     |
84   |         .map_err(|e| e.to_string())
     |                        ^^^^^^^^^ method cannot be called on `SandboxError` due to unsatisfied trait bounds
     |
    ::: src\sandbox\runtime.rs:17:1
     |
17   | pub enum SandboxError {
     | --------------------- method `to_string` not found for this enum because it doesn't satisfy `SandboxError: ToString` or `SandboxError: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `SandboxError: std::fmt::Display`
             which is required by `SandboxError: ToString`
note: the trait `std::fmt::Display` must be implemented
    --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\fmt\mod.rs:1003:1
     |
1003 | pub trait Display: PointeeSized {
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following trait defines an item `to_string`, perhaps you need to implement it:
             candidate #1: `ToString`

error[E0599]: `SandboxError` doesn't implement `std::fmt::Display`
    --> src\commands\sandbox.rs:123:53
     |
123  |     state.update_config(config).await.map_err(|e| e.to_string())
     |                                                     ^^^^^^^^^ method cannot be called on `SandboxError` due to unsatisfied trait bounds
     |
    ::: src\sandbox\runtime.rs:17:1
     |
17   | pub enum SandboxError {
     | --------------------- method `to_string` not found for this enum because it doesn't satisfy `SandboxError: ToString` or `SandboxError: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `SandboxError: std::fmt::Display`
             which is required by `SandboxError: ToString`
note: the trait `std::fmt::Display` must be implemented
    --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\fmt\mod.rs:1003:1
     |
1003 | pub trait Display: PointeeSized {
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following trait defines an item `to_string`, perhaps you need to implement it:
             candidate #1: `ToString`

error[E0599]: `SandboxError` doesn't implement `std::fmt::Display`
    --> src\commands\sandbox.rs:156:24
     |
156  |         .map_err(|e| e.to_string())
     |                        ^^^^^^^^^ method cannot be called on `SandboxError` due to unsatisfied trait bounds
     |
    ::: src\sandbox\runtime.rs:17:1
     |
17   | pub enum SandboxError {
     | --------------------- method `to_string` not found for this enum because it doesn't satisfy `SandboxError: ToString` or `SandboxError: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `SandboxError: std::fmt::Display`
             which is required by `SandboxError: ToString`
note: the trait `std::fmt::Display` must be implemented
    --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\fmt\mod.rs:1003:1
     |
1003 | pub trait Display: PointeeSized {
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following trait defines an item `to_string`, perhaps you need to implement it:
             candidate #1: `ToString`

error[E0599]: `SandboxError` doesn't implement `std::fmt::Display`
    --> src\commands\sandbox.rs:167:48
     |
167  |     state.execute(request).await.map_err(|e| e.to_string())
     |                                                ^^^^^^^^^ method cannot be called on `SandboxError` due to unsatisfied trait bounds
     |
    ::: src\sandbox\runtime.rs:17:1
     |
17   | pub enum SandboxError {
     | --------------------- method `to_string` not found for this enum because it doesn't satisfy `SandboxError: ToString` or `SandboxError: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `SandboxError: std::fmt::Display`
             which is required by `SandboxError: ToString`
note: the trait `std::fmt::Display` must be implemented
    --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\fmt\mod.rs:1003:1
     |
1003 | pub trait Display: PointeeSized {
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following trait defines an item `to_string`, perhaps you need to implement it:
             candidate #1: `ToString`

error[E0599]: `SandboxError` doesn't implement `std::fmt::Display`
    --> src\commands\sandbox.rs:179:48
     |
179  |     state.execute(request).await.map_err(|e| e.to_string())
     |                                                ^^^^^^^^^ method cannot be called on `SandboxError` due to unsatisfied trait bounds
     |
    ::: src\sandbox\runtime.rs:17:1
     |
17   | pub enum SandboxError {
     | --------------------- method `to_string` not found for this enum because it doesn't satisfy `SandboxError: ToString` or `SandboxError: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `SandboxError: std::fmt::Display`
             which is required by `SandboxError: ToString`
note: the trait `std::fmt::Display` must be implemented
    --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\fmt\mod.rs:1003:1
     |
1003 | pub trait Display: PointeeSized {
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following trait defines an item `to_string`, perhaps you need to implement it:
             candidate #1: `ToString`

error[E0599]: `SandboxError` doesn't implement `std::fmt::Display`
    --> src\commands\sandbox.rs:200:45
     |
200  |     state.save_config().await.map_err(|e| e.to_string())
     |                                             ^^^^^^^^^ method cannot be called on `SandboxError` due to unsatisfied trait bounds
     |
    ::: src\sandbox\runtime.rs:17:1
     |
17   | pub enum SandboxError {
     | --------------------- method `to_string` not found for this enum because it doesn't satisfy `SandboxError: ToString` or `SandboxError: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `SandboxError: std::fmt::Display`
             which is required by `SandboxError: ToString`
note: the trait `std::fmt::Display` must be implemented
    --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\fmt\mod.rs:1003:1
     |
1003 | pub trait Display: PointeeSized {
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following trait defines an item `to_string`, perhaps you need to implement it:
             candidate #1: `ToString`

error[E0599]: `SandboxError` doesn't implement `std::fmt::Display`
    --> src\commands\sandbox.rs:212:45
     |
212  |     state.save_config().await.map_err(|e| e.to_string())
     |                                             ^^^^^^^^^ method cannot be called on `SandboxError` due to unsatisfied trait bounds
     |
    ::: src\sandbox\runtime.rs:17:1
     |
17   | pub enum SandboxError {
     | --------------------- method `to_string` not found for this enum because it doesn't satisfy `SandboxError: ToString` or `SandboxError: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `SandboxError: std::fmt::Display`
             which is required by `SandboxError: ToString`
note: the trait `std::fmt::Display` must be implemented
    --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\fmt\mod.rs:1003:1
     |
1003 | pub trait Display: PointeeSized {
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following trait defines an item `to_string`, perhaps you need to implement it:
             candidate #1: `ToString`

error[E0599]: `SandboxError` doesn't implement `std::fmt::Display`
    --> src\commands\sandbox.rs:224:45
     |
224  |     state.save_config().await.map_err(|e| e.to_string())
     |                                             ^^^^^^^^^ method cannot be called on `SandboxError` due to unsatisfied trait bounds
     |
    ::: src\sandbox\runtime.rs:17:1
     |
17   | pub enum SandboxError {
     | --------------------- method `to_string` not found for this enum because it doesn't satisfy `SandboxError: ToString` or `SandboxError: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `SandboxError: std::fmt::Display`
             which is required by `SandboxError: ToString`
note: the trait `std::fmt::Display` must be implemented
    --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\fmt\mod.rs:1003:1
     |
1003 | pub trait Display: PointeeSized {
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following trait defines an item `to_string`, perhaps you need to implement it:
             candidate #1: `ToString`

error[E0599]: `SandboxError` doesn't implement `std::fmt::Display`
    --> src\commands\sandbox.rs:236:45
     |
236  |     state.save_config().await.map_err(|e| e.to_string())
     |                                             ^^^^^^^^^ method cannot be called on `SandboxError` due to unsatisfied trait bounds
     |
    ::: src\sandbox\runtime.rs:17:1
     |
17   | pub enum SandboxError {
     | --------------------- method `to_string` not found for this enum because it doesn't satisfy `SandboxError: ToString` or `SandboxError: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `SandboxError: std::fmt::Display`
             which is required by `SandboxError: ToString`
note: the trait `std::fmt::Display` must be implemented
    --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\fmt\mod.rs:1003:1
     |
1003 | pub trait Display: PointeeSized {
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following trait defines an item `to_string`, perhaps you need to implement it:
             candidate #1: `ToString`

error[E0599]: `SandboxError` doesn't implement `std::fmt::Display`
    --> src\commands\sandbox.rs:248:45
     |
248  |     state.save_config().await.map_err(|e| e.to_string())
     |                                             ^^^^^^^^^ method cannot be called on `SandboxError` due to unsatisfied trait bounds
     |
    ::: src\sandbox\runtime.rs:17:1
     |
17   | pub enum SandboxError {
     | --------------------- method `to_string` not found for this enum because it doesn't satisfy `SandboxError: ToString` or `SandboxError: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `SandboxError: std::fmt::Display`
             which is required by `SandboxError: ToString`
note: the trait `std::fmt::Display` must be implemented
    --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\fmt\mod.rs:1003:1
     |
1003 | pub trait Display: PointeeSized {
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following trait defines an item `to_string`, perhaps you need to implement it:
             candidate #1: `ToString`

error[E0599]: `SandboxError` doesn't implement `std::fmt::Display`
    --> src\commands\sandbox.rs:265:45
     |
265  |     state.cleanup_all().await.map_err(|e| e.to_string())
     |                                             ^^^^^^^^^ method cannot be called on `SandboxError` due to unsatisfied trait bounds
     |
    ::: src\sandbox\runtime.rs:17:1
     |
17   | pub enum SandboxError {
     | --------------------- method `to_string` not found for this enum because it doesn't satisfy `SandboxError: ToString` or `SandboxError: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `SandboxError: std::fmt::Display`
             which is required by `SandboxError: ToString`
note: the trait `std::fmt::Display` must be implemented
    --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\fmt\mod.rs:1003:1
     |
1003 | pub trait Display: PointeeSized {
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following trait defines an item `to_string`, perhaps you need to implement it:
             candidate #1: `ToString`

error[E0599]: `SandboxError` doesn't implement `std::fmt::Display`
    --> src\commands\sandbox.rs:280:24
     |
280  |         .map_err(|e| e.to_string())
     |                        ^^^^^^^^^ method cannot be called on `SandboxError` due to unsatisfied trait bounds
     |
    ::: src\sandbox\runtime.rs:17:1
     |
17   | pub enum SandboxError {
     | --------------------- method `to_string` not found for this enum because it doesn't satisfy `SandboxError: ToString` or `SandboxError: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `SandboxError: std::fmt::Display`
             which is required by `SandboxError: ToString`
note: the trait `std::fmt::Display` must be implemented
    --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\fmt\mod.rs:1003:1
     |
1003 | pub trait Display: PointeeSized {
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following trait defines an item `to_string`, perhaps you need to implement it:
             candidate #1: `ToString`

error[E0599]: `SandboxError` doesn't implement `std::fmt::Display`
    --> src\commands\sandbox.rs:295:24
     |
295  |         .map_err(|e| e.to_string())
     |                        ^^^^^^^^^ method cannot be called on `SandboxError` due to unsatisfied trait bounds
     |
    ::: src\sandbox\runtime.rs:17:1
     |
17   | pub enum SandboxError {
     | --------------------- method `to_string` not found for this enum because it doesn't satisfy `SandboxError: ToString` or `SandboxError: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `SandboxError: std::fmt::Display`
             which is required by `SandboxError: ToString`
note: the trait `std::fmt::Display` must be implemented
    --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\fmt\mod.rs:1003:1
     |
1003 | pub trait Display: PointeeSized {
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following trait defines an item `to_string`, perhaps you need to implement it:
             candidate #1: `ToString`

error[E0599]: `SandboxError` doesn't implement `std::fmt::Display`
    --> src\commands\sandbox.rs:321:45
     |
321  |     state.end_session().await.map_err(|e| e.to_string())
     |                                             ^^^^^^^^^ method cannot be called on `SandboxError` due to unsatisfied trait bounds
     |
    ::: src\sandbox\runtime.rs:17:1
     |
17   | pub enum SandboxError {
     | --------------------- method `to_string` not found for this enum because it doesn't satisfy `SandboxError: ToString` or `SandboxError: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `SandboxError: std::fmt::Display`
             which is required by `SandboxError: ToString`
note: the trait `std::fmt::Display` must be implemented
    --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\fmt\mod.rs:1003:1
     |
1003 | pub trait Display: PointeeSized {
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following trait defines an item `to_string`, perhaps you need to implement it:
             candidate #1: `ToString`

error[E0599]: `SandboxError` doesn't implement `std::fmt::Display`
    --> src\commands\sandbox.rs:333:24
     |
333  |         .map_err(|e| e.to_string())
     |                        ^^^^^^^^^ method cannot be called on `SandboxError` due to unsatisfied trait bounds
     |
    ::: src\sandbox\runtime.rs:17:1
     |
17   | pub enum SandboxError {
     | --------------------- method `to_string` not found for this enum because it doesn't satisfy `SandboxError: ToString` or `SandboxError: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `SandboxError: std::fmt::Display`
             which is required by `SandboxError: ToString`
note: the trait `std::fmt::Display` must be implemented
    --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\fmt\mod.rs:1003:1
     |
1003 | pub trait Display: PointeeSized {
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following trait defines an item `to_string`, perhaps you need to implement it:
             candidate #1: `ToString`

error[E0599]: `SandboxError` doesn't implement `std::fmt::Display`
    --> src\commands\sandbox.rs:342:48
     |
342  |     state.get_session(&id).await.map_err(|e| e.to_string())
     |                                                ^^^^^^^^^ method cannot be called on `SandboxError` due to unsatisfied trait bounds
     |
    ::: src\sandbox\runtime.rs:17:1
     |
17   | pub enum SandboxError {
     | --------------------- method `to_string` not found for this enum because it doesn't satisfy `SandboxError: ToString` or `SandboxError: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `SandboxError: std::fmt::Display`
             which is required by `SandboxError: ToString`
note: the trait `std::fmt::Display` must be implemented
    --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\fmt\mod.rs:1003:1
     |
1003 | pub trait Display: PointeeSized {
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following trait defines an item `to_string`, perhaps you need to implement it:
             candidate #1: `ToString`

error[E0599]: `SandboxError` doesn't implement `std::fmt::Display`
    --> src\commands\sandbox.rs:355:24
     |
355  |         .map_err(|e| e.to_string())
     |                        ^^^^^^^^^ method cannot be called on `SandboxError` due to unsatisfied trait bounds
     |
    ::: src\sandbox\runtime.rs:17:1
     |
17   | pub enum SandboxError {
     | --------------------- method `to_string` not found for this enum because it doesn't satisfy `SandboxError: ToString` or `SandboxError: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `SandboxError: std::fmt::Display`
             which is required by `SandboxError: ToString`
note: the trait `std::fmt::Display` must be implemented
    --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\fmt\mod.rs:1003:1
     |
1003 | pub trait Display: PointeeSized {
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following trait defines an item `to_string`, perhaps you need to implement it:
             candidate #1: `ToString`

error[E0599]: `SandboxError` doesn't implement `std::fmt::Display`
    --> src\commands\sandbox.rs:366:50
     |
366  |     state.get_execution(&id).await.map_err(|e| e.to_string())
     |                                                  ^^^^^^^^^ method cannot be called on `SandboxError` due to unsatisfied trait bounds
     |
    ::: src\sandbox\runtime.rs:17:1
     |
17   | pub enum SandboxError {
     | --------------------- method `to_string` not found for this enum because it doesn't satisfy `SandboxError: ToString` or `SandboxError: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `SandboxError: std::fmt::Display`
             which is required by `SandboxError: ToString`
note: the trait `std::fmt::Display` must be implemented
    --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\fmt\mod.rs:1003:1
     |
1003 | pub trait Display: PointeeSized {
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following trait defines an item `to_string`, perhaps you need to implement it:
             candidate #1: `ToString`

error[E0599]: `SandboxError` doesn't implement `std::fmt::Display`
    --> src\commands\sandbox.rs:378:24
     |
378  |         .map_err(|e| e.to_string())
     |                        ^^^^^^^^^ method cannot be called on `SandboxError` due to unsatisfied trait bounds
     |
    ::: src\sandbox\runtime.rs:17:1
     |
17   | pub enum SandboxError {
     | --------------------- method `to_string` not found for this enum because it doesn't satisfy `SandboxError: ToString` or `SandboxError: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `SandboxError: std::fmt::Display`
             which is required by `SandboxError: ToString`
note: the trait `std::fmt::Display` must be implemented
    --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\fmt\mod.rs:1003:1
     |
1003 | pub trait Display: PointeeSized {
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following trait defines an item `to_string`, perhaps you need to implement it:
             candidate #1: `ToString`

error[E0599]: `SandboxError` doesn't implement `std::fmt::Display`
    --> src\commands\sandbox.rs:390:24
     |
390  |         .map_err(|e| e.to_string())
     |                        ^^^^^^^^^ method cannot be called on `SandboxError` due to unsatisfied trait bounds
     |
    ::: src\sandbox\runtime.rs:17:1
     |
17   | pub enum SandboxError {
     | --------------------- method `to_string` not found for this enum because it doesn't satisfy `SandboxError: ToString` or `SandboxError: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `SandboxError: std::fmt::Display`
             which is required by `SandboxError: ToString`
note: the trait `std::fmt::Display` must be implemented
    --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\fmt\mod.rs:1003:1
     |
1003 | pub trait Display: PointeeSized {
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following trait defines an item `to_string`, perhaps you need to implement it:
             candidate #1: `ToString`

error[E0599]: `SandboxError` doesn't implement `std::fmt::Display`
    --> src\commands\sandbox.rs:399:53
     |
399  |     state.delete_execution(&id).await.map_err(|e| e.to_string())
     |                                                     ^^^^^^^^^ method cannot be called on `SandboxError` due to unsatisfied trait bounds
     |
    ::: src\sandbox\runtime.rs:17:1
     |
17   | pub enum SandboxError {
     | --------------------- method `to_string` not found for this enum because it doesn't satisfy `SandboxError: ToString` or `SandboxError: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `SandboxError: std::fmt::Display`
             which is required by `SandboxError: ToString`
note: the trait `std::fmt::Display` must be implemented
    --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\fmt\mod.rs:1003:1
     |
1003 | pub trait Display: PointeeSized {
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following trait defines an item `to_string`, perhaps you need to implement it:
             candidate #1: `ToString`

error[E0599]: `SandboxError` doesn't implement `std::fmt::Display`
    --> src\commands\sandbox.rs:411:24
     |
411  |         .map_err(|e| e.to_string())
     |                        ^^^^^^^^^ method cannot be called on `SandboxError` due to unsatisfied trait bounds
     |
    ::: src\sandbox\runtime.rs:17:1
     |
17   | pub enum SandboxError {
     | --------------------- method `to_string` not found for this enum because it doesn't satisfy `SandboxError: ToString` or `SandboxError: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `SandboxError: std::fmt::Display`
             which is required by `SandboxError: ToString`
note: the trait `std::fmt::Display` must be implemented
    --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\fmt\mod.rs:1003:1
     |
1003 | pub trait Display: PointeeSized {
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following trait defines an item `to_string`, perhaps you need to implement it:
             candidate #1: `ToString`

error[E0599]: `SandboxError` doesn't implement `std::fmt::Display`
    --> src\commands\sandbox.rs:424:24
     |
424  |         .map_err(|e| e.to_string())
     |                        ^^^^^^^^^ method cannot be called on `SandboxError` due to unsatisfied trait bounds
     |
    ::: src\sandbox\runtime.rs:17:1
     |
17   | pub enum SandboxError {
     | --------------------- method `to_string` not found for this enum because it doesn't satisfy `SandboxError: ToString` or `SandboxError: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `SandboxError: std::fmt::Display`
             which is required by `SandboxError: ToString`
note: the trait `std::fmt::Display` must be implemented
    --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\fmt\mod.rs:1003:1
     |
1003 | pub trait Display: PointeeSized {
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following trait defines an item `to_string`, perhaps you need to implement it:
             candidate #1: `ToString`

error[E0599]: `SandboxError` doesn't implement `std::fmt::Display`
    --> src\commands\sandbox.rs:437:24
     |
437  |         .map_err(|e| e.to_string())
     |                        ^^^^^^^^^ method cannot be called on `SandboxError` due to unsatisfied trait bounds
     |
    ::: src\sandbox\runtime.rs:17:1
     |
17   | pub enum SandboxError {
     | --------------------- method `to_string` not found for this enum because it doesn't satisfy `SandboxError: ToString` or `SandboxError: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `SandboxError: std::fmt::Display`
             which is required by `SandboxError: ToString`
note: the trait `std::fmt::Display` must be implemented
    --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\fmt\mod.rs:1003:1
     |
1003 | pub trait Display: PointeeSized {
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following trait defines an item `to_string`, perhaps you need to implement it:
             candidate #1: `ToString`

error[E0599]: `SandboxError` doesn't implement `std::fmt::Display`
    --> src\commands\sandbox.rs:454:24
     |
454  |         .map_err(|e| e.to_string())
     |                        ^^^^^^^^^ method cannot be called on `SandboxError` due to unsatisfied trait bounds
     |
    ::: src\sandbox\runtime.rs:17:1
     |
17   | pub enum SandboxError {
     | --------------------- method `to_string` not found for this enum because it doesn't satisfy `SandboxError: ToString` or `SandboxError: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `SandboxError: std::fmt::Display`
             which is required by `SandboxError: ToString`
note: the trait `std::fmt::Display` must be implemented
    --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\fmt\mod.rs:1003:1
     |
1003 | pub trait Display: PointeeSized {
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following trait defines an item `to_string`, perhaps you need to implement it:
             candidate #1: `ToString`

error[E0599]: `SandboxError` doesn't implement `std::fmt::Display`
    --> src\commands\sandbox.rs:492:56
     |
492  |     state.create_snippet(&snippet).await.map_err(|e| e.to_string())
     |                                                        ^^^^^^^^^ method cannot be called on `SandboxError` due to unsatisfied trait bounds
     |
    ::: src\sandbox\runtime.rs:17:1
     |
17   | pub enum SandboxError {
     | --------------------- method `to_string` not found for this enum because it doesn't satisfy `SandboxError: ToString` or `SandboxError: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `SandboxError: std::fmt::Display`
             which is required by `SandboxError: ToString`
note: the trait `std::fmt::Display` must be implemented
    --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\fmt\mod.rs:1003:1
     |
1003 | pub trait Display: PointeeSized {
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following trait defines an item `to_string`, perhaps you need to implement it:
             candidate #1: `ToString`

error[E0599]: `SandboxError` doesn't implement `std::fmt::Display`
    --> src\commands\sandbox.rs:501:48
     |
501  |     state.get_snippet(&id).await.map_err(|e| e.to_string())
     |                                                ^^^^^^^^^ method cannot be called on `SandboxError` due to unsatisfied trait bounds
     |
    ::: src\sandbox\runtime.rs:17:1
     |
17   | pub enum SandboxError {
     | --------------------- method `to_string` not found for this enum because it doesn't satisfy `SandboxError: ToString` or `SandboxError: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `SandboxError: std::fmt::Display`
             which is required by `SandboxError: ToString`
note: the trait `std::fmt::Display` must be implemented
    --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\fmt\mod.rs:1003:1
     |
1003 | pub trait Display: PointeeSized {
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following trait defines an item `to_string`, perhaps you need to implement it:
             candidate #1: `ToString`

error[E0599]: `SandboxError` doesn't implement `std::fmt::Display`
    --> src\commands\sandbox.rs:510:55
     |
510  |     state.query_snippets(&filter).await.map_err(|e| e.to_string())
     |                                                       ^^^^^^^^^ method cannot be called on `SandboxError` due to unsatisfied trait bounds
     |
    ::: src\sandbox\runtime.rs:17:1
     |
17   | pub enum SandboxError {
     | --------------------- method `to_string` not found for this enum because it doesn't satisfy `SandboxError: ToString` or `SandboxError: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `SandboxError: std::fmt::Display`
             which is required by `SandboxError: ToString`
note: the trait `std::fmt::Display` must be implemented
    --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\fmt\mod.rs:1003:1
     |
1003 | pub trait Display: PointeeSized {
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following trait defines an item `to_string`, perhaps you need to implement it:
             candidate #1: `ToString`

error[E0599]: `SandboxError` doesn't implement `std::fmt::Display`
    --> src\commands\sandbox.rs:519:56
     |
519  |     state.update_snippet(&snippet).await.map_err(|e| e.to_string())
     |                                                        ^^^^^^^^^ method cannot be called on `SandboxError` due to unsatisfied trait bounds
     |
    ::: src\sandbox\runtime.rs:17:1
     |
17   | pub enum SandboxError {
     | --------------------- method `to_string` not found for this enum because it doesn't satisfy `SandboxError: ToString` or `SandboxError: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `SandboxError: std::fmt::Display`
             which is required by `SandboxError: ToString`
note: the trait `std::fmt::Display` must be implemented
    --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\fmt\mod.rs:1003:1
     |
1003 | pub trait Display: PointeeSized {
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following trait defines an item `to_string`, perhaps you need to implement it:
             candidate #1: `ToString`

error[E0599]: `SandboxError` doesn't implement `std::fmt::Display`
    --> src\commands\sandbox.rs:528:51
     |
528  |     state.delete_snippet(&id).await.map_err(|e| e.to_string())
     |                                                   ^^^^^^^^^ method cannot be called on `SandboxError` due to unsatisfied trait bounds
     |
    ::: src\sandbox\runtime.rs:17:1
     |
17   | pub enum SandboxError {
     | --------------------- method `to_string` not found for this enum because it doesn't satisfy `SandboxError: ToString` or `SandboxError: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `SandboxError: std::fmt::Display`
             which is required by `SandboxError: ToString`
note: the trait `std::fmt::Display` must be implemented
    --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\fmt\mod.rs:1003:1
     |
1003 | pub trait Display: PointeeSized {
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following trait defines an item `to_string`, perhaps you need to implement it:
             candidate #1: `ToString`

error[E0599]: `SandboxError` doesn't implement `std::fmt::Display`
    --> src\commands\sandbox.rs:550:24
     |
550  |         .map_err(|e| e.to_string())
     |                        ^^^^^^^^^ method cannot be called on `SandboxError` due to unsatisfied trait bounds
     |
    ::: src\sandbox\runtime.rs:17:1
     |
17   | pub enum SandboxError {
     | --------------------- method `to_string` not found for this enum because it doesn't satisfy `SandboxError: ToString` or `SandboxError: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `SandboxError: std::fmt::Display`
             which is required by `SandboxError: ToString`
note: the trait `std::fmt::Display` must be implemented
    --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\fmt\mod.rs:1003:1
     |
1003 | pub trait Display: PointeeSized {
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following trait defines an item `to_string`, perhaps you need to implement it:
             candidate #1: `ToString`

error[E0599]: `SandboxError` doesn't implement `std::fmt::Display`
    --> src\commands\sandbox.rs:559:52
     |
559  |     state.execute_snippet(&id).await.map_err(|e| e.to_string())
     |                                                    ^^^^^^^^^ method cannot be called on `SandboxError` due to unsatisfied trait bounds
     |
    ::: src\sandbox\runtime.rs:17:1
     |
17   | pub enum SandboxError {
     | --------------------- method `to_string` not found for this enum because it doesn't satisfy `SandboxError: ToString` or `SandboxError: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `SandboxError: std::fmt::Display`
             which is required by `SandboxError: ToString`
note: the trait `std::fmt::Display` must be implemented
    --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\fmt\mod.rs:1003:1
     |
1003 | pub trait Display: PointeeSized {
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following trait defines an item `to_string`, perhaps you need to implement it:
             candidate #1: `ToString`

error[E0599]: `SandboxError` doesn't implement `std::fmt::Display`
    --> src\commands\sandbox.rs:573:24
     |
573  |         .map_err(|e| e.to_string())
     |                        ^^^^^^^^^ method cannot be called on `SandboxError` due to unsatisfied trait bounds
     |
    ::: src\sandbox\runtime.rs:17:1
     |
17   | pub enum SandboxError {
     | --------------------- method `to_string` not found for this enum because it doesn't satisfy `SandboxError: ToString` or `SandboxError: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `SandboxError: std::fmt::Display`
             which is required by `SandboxError: ToString`
note: the trait `std::fmt::Display` must be implemented
    --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\fmt\mod.rs:1003:1
     |
1003 | pub trait Display: PointeeSized {
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following trait defines an item `to_string`, perhaps you need to implement it:
             candidate #1: `ToString`

error[E0599]: `SandboxError` doesn't implement `std::fmt::Display`
    --> src\commands\sandbox.rs:581:56
     |
581  |     state.get_all_language_stats().await.map_err(|e| e.to_string())
     |                                                        ^^^^^^^^^ method cannot be called on `SandboxError` due to unsatisfied trait bounds
     |
    ::: src\sandbox\runtime.rs:17:1
     |
17   | pub enum SandboxError {
     | --------------------- method `to_string` not found for this enum because it doesn't satisfy `SandboxError: ToString` or `SandboxError: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `SandboxError: std::fmt::Display`
             which is required by `SandboxError: ToString`
note: the trait `std::fmt::Display` must be implemented
    --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\fmt\mod.rs:1003:1
     |
1003 | pub trait Display: PointeeSized {
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following trait defines an item `to_string`, perhaps you need to implement it:
             candidate #1: `ToString`

error[E0599]: `SandboxError` doesn't implement `std::fmt::Display`
    --> src\commands\sandbox.rs:589:51
     |
589  |     state.get_sandbox_stats().await.map_err(|e| e.to_string())
     |                                                   ^^^^^^^^^ method cannot be called on `SandboxError` due to unsatisfied trait bounds
     |
    ::: src\sandbox\runtime.rs:17:1
     |
17   | pub enum SandboxError {
     | --------------------- method `to_string` not found for this enum because it doesn't satisfy `SandboxError: ToString` or `SandboxError: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `SandboxError: std::fmt::Display`
             which is required by `SandboxError: ToString`
note: the trait `std::fmt::Display` must be implemented
    --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\fmt\mod.rs:1003:1
     |
1003 | pub trait Display: PointeeSized {
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following trait defines an item `to_string`, perhaps you need to implement it:
             candidate #1: `ToString`

error[E0599]: `SandboxError` doesn't implement `std::fmt::Display`
    --> src\commands\sandbox.rs:601:24
     |
601  |         .map_err(|e| e.to_string())
     |                        ^^^^^^^^^ method cannot be called on `SandboxError` due to unsatisfied trait bounds
     |
    ::: src\sandbox\runtime.rs:17:1
     |
17   | pub enum SandboxError {
     | --------------------- method `to_string` not found for this enum because it doesn't satisfy `SandboxError: ToString` or `SandboxError: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `SandboxError: std::fmt::Display`
             which is required by `SandboxError: ToString`
note: the trait `std::fmt::Display` must be implemented
    --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\fmt\mod.rs:1003:1
     |
1003 | pub trait Display: PointeeSized {
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following trait defines an item `to_string`, perhaps you need to implement it:
             candidate #1: `ToString`

error[E0599]: `SandboxError` doesn't implement `std::fmt::Display`
    --> src\commands\sandbox.rs:611:45
     |
611  |     state.export_data().await.map_err(|e| e.to_string())
     |                                             ^^^^^^^^^ method cannot be called on `SandboxError` due to unsatisfied trait bounds
     |
    ::: src\sandbox\runtime.rs:17:1
     |
17   | pub enum SandboxError {
     | --------------------- method `to_string` not found for this enum because it doesn't satisfy `SandboxError: ToString` or `SandboxError: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `SandboxError: std::fmt::Display`
             which is required by `SandboxError: ToString`
note: the trait `std::fmt::Display` must be implemented
    --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\fmt\mod.rs:1003:1
     |
1003 | pub trait Display: PointeeSized {
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following trait defines an item `to_string`, perhaps you need to implement it:
             candidate #1: `ToString`

error[E0599]: `SandboxError` doesn't implement `std::fmt::Display`
    --> src\commands\sandbox.rs:619:46
     |
619  |     state.get_all_tags().await.map_err(|e| e.to_string())
     |                                              ^^^^^^^^^ method cannot be called on `SandboxError` due to unsatisfied trait bounds
     |
    ::: src\sandbox\runtime.rs:17:1
     |
17   | pub enum SandboxError {
     | --------------------- method `to_string` not found for this enum because it doesn't satisfy `SandboxError: ToString` or `SandboxError: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `SandboxError: std::fmt::Display`
             which is required by `SandboxError: ToString`
note: the trait `std::fmt::Display` must be implemented
    --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\fmt\mod.rs:1003:1
     |
1003 | pub trait Display: PointeeSized {
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following trait defines an item `to_string`, perhaps you need to implement it:
             candidate #1: `ToString`

error[E0599]: `SandboxError` doesn't implement `std::fmt::Display`
    --> src\commands\sandbox.rs:627:52
     |
627  |     state.get_all_categories().await.map_err(|e| e.to_string())
     |                                                    ^^^^^^^^^ method cannot be called on `SandboxError` due to unsatisfied trait bounds
     |
    ::: src\sandbox\runtime.rs:17:1
     |
17   | pub enum SandboxError {
     | --------------------- method `to_string` not found for this enum because it doesn't satisfy `SandboxError: ToString` or `SandboxError: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `SandboxError: std::fmt::Display`
             which is required by `SandboxError: ToString`
note: the trait `std::fmt::Display` must be implemented
    --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\fmt\mod.rs:1003:1
     |
1003 | pub trait Display: PointeeSized {
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following trait defines an item `to_string`, perhaps you need to implement it:
             candidate #1: `ToString`

error[E0599]: `SandboxError` doesn't implement `std::fmt::Display`
    --> src\commands\sandbox.rs:635:45
     |
635  |     state.get_db_size().await.map_err(|e| e.to_string())
     |                                             ^^^^^^^^^ method cannot be called on `SandboxError` due to unsatisfied trait bounds
     |
    ::: src\sandbox\runtime.rs:17:1
     |
17   | pub enum SandboxError {
     | --------------------- method `to_string` not found for this enum because it doesn't satisfy `SandboxError: ToString` or `SandboxError: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `SandboxError: std::fmt::Display`
             which is required by `SandboxError: ToString`
note: the trait `std::fmt::Display` must be implemented
    --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\fmt\mod.rs:1003:1
     |
1003 | pub trait Display: PointeeSized {
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following trait defines an item `to_string`, perhaps you need to implement it:
             candidate #1: `ToString`

error[E0599]: `SandboxError` doesn't implement `std::fmt::Display`
    --> src\commands\sandbox.rs:643:43
     |
643  |     state.vacuum_db().await.map_err(|e| e.to_string())
     |                                           ^^^^^^^^^ method cannot be called on `SandboxError` due to unsatisfied trait bounds
     |
    ::: src\sandbox\runtime.rs:17:1
     |
17   | pub enum SandboxError {
     | --------------------- method `to_string` not found for this enum because it doesn't satisfy `SandboxError: ToString` or `SandboxError: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `SandboxError: std::fmt::Display`
             which is required by `SandboxError: ToString`
note: the trait `std::fmt::Display` must be implemented
    --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\fmt\mod.rs:1003:1
     |
1003 | pub trait Display: PointeeSized {
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following trait defines an item `to_string`, perhaps you need to implement it:
             candidate #1: `ToString`

error[E0599]: `SandboxError` doesn't implement `std::fmt::Display`
    --> src\commands\sandbox.rs:672:24
     |
672  |         .map_err(|e| e.to_string())
     |                        ^^^^^^^^^ method cannot be called on `SandboxError` due to unsatisfied trait bounds
     |
    ::: src\sandbox\runtime.rs:17:1
     |
17   | pub enum SandboxError {
     | --------------------- method `to_string` not found for this enum because it doesn't satisfy `SandboxError: ToString` or `SandboxError: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `SandboxError: std::fmt::Display`
             which is required by `SandboxError: ToString`
note: the trait `std::fmt::Display` must be implemented
    --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\fmt\mod.rs:1003:1
     |
1003 | pub trait Display: PointeeSized {
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following trait defines an item `to_string`, perhaps you need to implement it:
             candidate #1: `ToString`

error[E0038]: the trait `Transport` is not dyn compatible
  --> src\mcp\client.rs:54:19
   |
54 |         Self::new(Arc::new(transport), notification_tx)
   |                   ^^^^^^^^^^^^^^^^^^^ `Transport` is not dyn compatible
   |
note: for a trait to be dyn compatible it needs to allow building a vtable
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
  --> src\mcp\transport\mod.rs:16:14
   |
14 | pub trait Transport: Send + Sync {
   |           --------- this trait is not dyn compatible...
15 |     /// Send a message through the transport
16 |     async fn send(&self, message: &str) -> McpResult<()>;
   |              ^^^^ ...because method `send` is `async`
...
19 |     async fn receive(&self) -> McpResult<String>;
   |              ^^^^^^^ ...because method `receive` is `async`
...
22 |     async fn close(&self) -> McpResult<()>;
   |              ^^^^^ ...because method `close` is `async`
   = help: consider moving `close` to another trait
   = help: consider moving `send` to another trait
   = help: consider moving `receive` to another trait
   = help: the following types implement `Transport`:
             mcp::transport::sse::SseTransport
             mcp::transport::stdio::StdioTransport
           consider defining an enum where each variant holds one of these types,
           implementing `Transport` for this new enum and using it instead

error[E0038]: the trait `Transport` is not dyn compatible
  --> src\mcp\client.rs:63:19
   |
63 |         Self::new(Arc::new(transport), notification_tx)
   |                   ^^^^^^^^^^^^^^^^^^^ `Transport` is not dyn compatible
   |
note: for a trait to be dyn compatible it needs to allow building a vtable
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
  --> src\mcp\transport\mod.rs:16:14
   |
14 | pub trait Transport: Send + Sync {
   |           --------- this trait is not dyn compatible...
15 |     /// Send a message through the transport
16 |     async fn send(&self, message: &str) -> McpResult<()>;
   |              ^^^^ ...because method `send` is `async`
...
19 |     async fn receive(&self) -> McpResult<String>;
   |              ^^^^^^^ ...because method `receive` is `async`
...
22 |     async fn close(&self) -> McpResult<()>;
   |              ^^^^^ ...because method `close` is `async`
   = help: consider moving `close` to another trait
   = help: consider moving `send` to another trait
   = help: consider moving `receive` to another trait
   = help: the following types implement `Transport`:
             mcp::transport::sse::SseTransport
             mcp::transport::stdio::StdioTransport
           consider defining an enum where each variant holds one of these types,
           implementing `Transport` for this new enum and using it instead

error[E0038]: the trait `Transport` is not dyn compatible
  --> src\mcp\client.rs:88:25
   |
88 |         let transport = self.transport.clone();
   |                         ^^^^^^^^^^^^^^^^^^^^^^ `Transport` is not dyn compatible
   |
note: for a trait to be dyn compatible it needs to allow building a vtable
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
  --> src\mcp\transport\mod.rs:16:14
   |
14 | pub trait Transport: Send + Sync {
   |           --------- this trait is not dyn compatible...
15 |     /// Send a message through the transport
16 |     async fn send(&self, message: &str) -> McpResult<()>;
   |              ^^^^ ...because method `send` is `async`
...
19 |     async fn receive(&self) -> McpResult<String>;
   |              ^^^^^^^ ...because method `receive` is `async`
...
22 |     async fn close(&self) -> McpResult<()>;
   |              ^^^^^ ...because method `close` is `async`
   = help: consider moving `close` to another trait
   = help: consider moving `send` to another trait
   = help: consider moving `receive` to another trait
   = help: the following types implement `Transport`:
             mcp::transport::sse::SseTransport
             mcp::transport::stdio::StdioTransport
           consider defining an enum where each variant holds one of these types,
           implementing `Transport` for this new enum and using it instead

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
  --> src\mcp\client.rs:92:22
   |
92 |         let handle = tokio::spawn(async move {
   |                      ^^^^^ use of unresolved module or unlinked crate `tokio`
   |
   = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`

error[E0038]: the trait `Transport` is not dyn compatible
  --> src\mcp\client.rs:94:23
   |
94 |                 match transport.receive().await {
   |                       ^^^^^^^^^^^^^^^^^^^ `Transport` is not dyn compatible
   |
note: for a trait to be dyn compatible it needs to allow building a vtable
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
  --> src\mcp\transport\mod.rs:16:14
   |
14 | pub trait Transport: Send + Sync {
   |           --------- this trait is not dyn compatible...
15 |     /// Send a message through the transport
16 |     async fn send(&self, message: &str) -> McpResult<()>;
   |              ^^^^ ...because method `send` is `async`
...
19 |     async fn receive(&self) -> McpResult<String>;
   |              ^^^^^^^ ...because method `receive` is `async`
...
22 |     async fn close(&self) -> McpResult<()>;
   |              ^^^^^ ...because method `close` is `async`
   = help: consider moving `close` to another trait
   = help: consider moving `send` to another trait
   = help: consider moving `receive` to another trait
   = help: the following types implement `Transport`:
             mcp::transport::sse::SseTransport
             mcp::transport::stdio::StdioTransport
           consider defining an enum where each variant holds one of these types,
           implementing `Transport` for this new enum and using it instead

error[E0038]: the trait `Transport` is not dyn compatible
   --> src\mcp\client.rs:132:29
    |
132 |                         if !transport.is_connected() {
    |                             ^^^^^^^^^^^^^^^^^^^^^^^^ `Transport` is not dyn compatible
    |
note: for a trait to be dyn compatible it needs to allow building a vtable
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
   --> src\mcp\transport\mod.rs:16:14
    |
14  | pub trait Transport: Send + Sync {
    |           --------- this trait is not dyn compatible...
15  |     /// Send a message through the transport
16  |     async fn send(&self, message: &str) -> McpResult<()>;
    |              ^^^^ ...because method `send` is `async`
...
19  |     async fn receive(&self) -> McpResult<String>;
    |              ^^^^^^^ ...because method `receive` is `async`
...
22  |     async fn close(&self) -> McpResult<()>;
    |              ^^^^^ ...because method `close` is `async`
    = help: consider moving `close` to another trait
    = help: consider moving `send` to another trait
    = help: consider moving `receive` to another trait
    = help: the following types implement `Transport`:
              mcp::transport::sse::SseTransport
              mcp::transport::stdio::StdioTransport
            consider defining an enum where each variant holds one of these types,
            implementing `Transport` for this new enum and using it instead

error[E0277]: `?` couldn't convert the error to `McpError`
   --> src\mcp\client.rs:152:54
    |
152 |         let message = serde_json::to_string(&request)?;
    |                       -------------------------------^ the trait `From<serde_json::Error>` is not implemented for `McpError`
    |                       |
    |                       this can't be annotated with `?` because it has type `Result<_, serde_json::Error>`
    |
note: `McpError` needs to implement `From<serde_json::Error>`
   --> src\mcp\error.rs:13:1
    |
13  | pub enum McpError {
    | ^^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait
    = help: the trait `From<serde_json::Error>` is not implemented for `McpError`
            but trait `From<JsonRpcError>` is implemented for it
    = help: for that trait implementation, expected `JsonRpcError`, found `serde_json::Error`

error[E0038]: the trait `Transport` is not dyn compatible
   --> src\mcp\client.rs:164:9
    |
164 |         self.transport.send(&message).await?;
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `Transport` is not dyn compatible
    |
note: for a trait to be dyn compatible it needs to allow building a vtable
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
   --> src\mcp\transport\mod.rs:16:14
    |
14  | pub trait Transport: Send + Sync {
    |           --------- this trait is not dyn compatible...
15  |     /// Send a message through the transport
16  |     async fn send(&self, message: &str) -> McpResult<()>;
    |              ^^^^ ...because method `send` is `async`
...
19  |     async fn receive(&self) -> McpResult<String>;
    |              ^^^^^^^ ...because method `receive` is `async`
...
22  |     async fn close(&self) -> McpResult<()>;
    |              ^^^^^ ...because method `close` is `async`
    = help: consider moving `close` to another trait
    = help: consider moving `send` to another trait
    = help: consider moving `receive` to another trait
    = help: the following types implement `Transport`:
              mcp::transport::sse::SseTransport
              mcp::transport::stdio::StdioTransport
            consider defining an enum where each variant holds one of these types,
            implementing `Transport` for this new enum and using it instead

error[E0277]: `?` couldn't convert the error to `McpError`
   --> src\mcp\client.rs:186:59
    |
186 |         let message = serde_json::to_string(&notification)?;
    |                       ------------------------------------^ the trait `From<serde_json::Error>` is not implemented for `McpError`
    |                       |
    |                       this can't be annotated with `?` because it has type `Result<_, serde_json::Error>`
    |
note: `McpError` needs to implement `From<serde_json::Error>`
   --> src\mcp\error.rs:13:1
    |
13  | pub enum McpError {
    | ^^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait
    = help: the trait `From<serde_json::Error>` is not implemented for `McpError`
            but trait `From<JsonRpcError>` is implemented for it
    = help: for that trait implementation, expected `JsonRpcError`, found `serde_json::Error`

error[E0038]: the trait `Transport` is not dyn compatible
   --> src\mcp\client.rs:187:9
    |
187 |         self.transport.send(&message).await
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `Transport` is not dyn compatible
    |
note: for a trait to be dyn compatible it needs to allow building a vtable
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
   --> src\mcp\transport\mod.rs:16:14
    |
14  | pub trait Transport: Send + Sync {
    |           --------- this trait is not dyn compatible...
15  |     /// Send a message through the transport
16  |     async fn send(&self, message: &str) -> McpResult<()>;
    |              ^^^^ ...because method `send` is `async`
...
19  |     async fn receive(&self) -> McpResult<String>;
    |              ^^^^^^^ ...because method `receive` is `async`
...
22  |     async fn close(&self) -> McpResult<()>;
    |              ^^^^^ ...because method `close` is `async`
    = help: consider moving `close` to another trait
    = help: consider moving `send` to another trait
    = help: consider moving `receive` to another trait
    = help: the following types implement `Transport`:
              mcp::transport::sse::SseTransport
              mcp::transport::stdio::StdioTransport
            consider defining an enum where each variant holds one of these types,
            implementing `Transport` for this new enum and using it instead

error[E0277]: `?` couldn't convert the error to `McpError`
   --> src\mcp\client.rs:201:75
    |
201 |         let init_result: InitializeResult = serde_json::from_value(result)?;
    |                                             ------------------------------^ the trait `From<serde_json::Error>` is not implemented for `McpError`
    |                                             |
    |                                             this can't be annotated with `?` because it has type `Result<_, serde_json::Error>`
    |
note: `McpError` needs to implement `From<serde_json::Error>`
   --> src\mcp\error.rs:13:1
    |
13  | pub enum McpError {
    | ^^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait
    = help: the trait `From<serde_json::Error>` is not implemented for `McpError`
            but trait `From<JsonRpcError>` is implemented for it
    = help: for that trait implementation, expected `JsonRpcError`, found `serde_json::Error`

error[E0277]: `?` couldn't convert the error to `McpError`
   --> src\mcp\client.rs:231:73
    |
231 |         let response: ToolsListResponse = serde_json::from_value(result)?;
    |                                           ------------------------------^ the trait `From<serde_json::Error>` is not implemented for `McpError`
    |                                           |
    |                                           this can't be annotated with `?` because it has type `Result<_, serde_json::Error>`
    |
note: `McpError` needs to implement `From<serde_json::Error>`
   --> src\mcp\error.rs:13:1
    |
13  | pub enum McpError {
    | ^^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait
    = help: the trait `From<serde_json::Error>` is not implemented for `McpError`
            but trait `From<JsonRpcError>` is implemented for it
    = help: for that trait implementation, expected `JsonRpcError`, found `serde_json::Error`

error[E0277]: `?` couldn't convert the error to `McpError`
   --> src\mcp\client.rs:247:81
    |
247 |             .send_request(methods::TOOLS_CALL, Some(serde_json::to_value(params)?))
    |                                                     ----------------------------^ the trait `From<serde_json::Error>` is not implemented for `McpError`
    |                                                     |
    |                                                     this can't be annotated with `?` because it has type `Result<_, serde_json::Error>`
    |
note: `McpError` needs to implement `From<serde_json::Error>`
   --> src\mcp\error.rs:13:1
    |
13  | pub enum McpError {
    | ^^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait
    = help: the trait `From<serde_json::Error>` is not implemented for `McpError`
            but trait `From<JsonRpcError>` is implemented for it
    = help: for that trait implementation, expected `JsonRpcError`, found `serde_json::Error`

error[E0277]: `?` couldn't convert the error to `McpError`
   --> src\mcp\client.rs:249:70
    |
249 |         let response: ToolCallResult = serde_json::from_value(result)?;
    |                                        ------------------------------^ the trait `From<serde_json::Error>` is not implemented for `McpError`
    |                                        |
    |                                        this can't be annotated with `?` because it has type `Result<_, serde_json::Error>`
    |
note: `McpError` needs to implement `From<serde_json::Error>`
   --> src\mcp\error.rs:13:1
    |
13  | pub enum McpError {
    | ^^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait
    = help: the trait `From<serde_json::Error>` is not implemented for `McpError`
            but trait `From<JsonRpcError>` is implemented for it
    = help: for that trait implementation, expected `JsonRpcError`, found `serde_json::Error`

error[E0277]: `?` couldn't convert the error to `McpError`
   --> src\mcp\client.rs:256:77
    |
256 |         let response: ResourcesListResponse = serde_json::from_value(result)?;
    |                                               ------------------------------^ the trait `From<serde_json::Error>` is not implemented for `McpError`
    |                                               |
    |                                               this can't be annotated with `?` because it has type `Result<_, serde_json::Error>`
    |
note: `McpError` needs to implement `From<serde_json::Error>`
   --> src\mcp\error.rs:13:1
    |
13  | pub enum McpError {
    | ^^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait
    = help: the trait `From<serde_json::Error>` is not implemented for `McpError`
            but trait `From<JsonRpcError>` is implemented for it
    = help: for that trait implementation, expected `JsonRpcError`, found `serde_json::Error`

error[E0277]: `?` couldn't convert the error to `McpError`
   --> src\mcp\client.rs:269:50
    |
269 |                 Some(serde_json::to_value(params)?),
    |                      ----------------------------^ the trait `From<serde_json::Error>` is not implemented for `McpError`
    |                      |
    |                      this can't be annotated with `?` because it has type `Result<_, serde_json::Error>`
    |
note: `McpError` needs to implement `From<serde_json::Error>`
   --> src\mcp\error.rs:13:1
    |
13  | pub enum McpError {
    | ^^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait
    = help: the trait `From<serde_json::Error>` is not implemented for `McpError`
            but trait `From<JsonRpcError>` is implemented for it
    = help: for that trait implementation, expected `JsonRpcError`, found `serde_json::Error`

error[E0277]: `?` couldn't convert the error to `McpError`
   --> src\mcp\client.rs:272:71
    |
272 |         let response: ResourceContent = serde_json::from_value(result)?;
    |                                         ------------------------------^ the trait `From<serde_json::Error>` is not implemented for `McpError`
    |                                         |
    |                                         this can't be annotated with `?` because it has type `Result<_, serde_json::Error>`
    |
note: `McpError` needs to implement `From<serde_json::Error>`
   --> src\mcp\error.rs:13:1
    |
13  | pub enum McpError {
    | ^^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait
    = help: the trait `From<serde_json::Error>` is not implemented for `McpError`
            but trait `From<JsonRpcError>` is implemented for it
    = help: for that trait implementation, expected `JsonRpcError`, found `serde_json::Error`

error[E0277]: `?` couldn't convert the error to `McpError`
   --> src\mcp\client.rs:295:75
    |
295 |         let response: PromptsListResponse = serde_json::from_value(result)?;
    |                                             ------------------------------^ the trait `From<serde_json::Error>` is not implemented for `McpError`
    |                                             |
    |                                             this can't be annotated with `?` because it has type `Result<_, serde_json::Error>`
    |
note: `McpError` needs to implement `From<serde_json::Error>`
   --> src\mcp\error.rs:13:1
    |
13  | pub enum McpError {
    | ^^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait
    = help: the trait `From<serde_json::Error>` is not implemented for `McpError`
            but trait `From<JsonRpcError>` is implemented for it
    = help: for that trait implementation, expected `JsonRpcError`, found `serde_json::Error`

error[E0277]: `?` couldn't convert the error to `McpError`
   --> src\mcp\client.rs:311:82
    |
311 |             .send_request(methods::PROMPTS_GET, Some(serde_json::to_value(params)?))
    |                                                      ----------------------------^ the trait `From<serde_json::Error>` is not implemented for `McpError`
    |                                                      |
    |                                                      this can't be annotated with `?` because it has type `Result<_, serde_json::Error>`
    |
note: `McpError` needs to implement `From<serde_json::Error>`
   --> src\mcp\error.rs:13:1
    |
13  | pub enum McpError {
    | ^^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait
    = help: the trait `From<serde_json::Error>` is not implemented for `McpError`
            but trait `From<JsonRpcError>` is implemented for it
    = help: for that trait implementation, expected `JsonRpcError`, found `serde_json::Error`

error[E0277]: `?` couldn't convert the error to `McpError`
   --> src\mcp\client.rs:313:69
    |
313 |         let response: PromptContent = serde_json::from_value(result)?;
    |                                       ------------------------------^ the trait `From<serde_json::Error>` is not implemented for `McpError`
    |                                       |
    |                                       this can't be annotated with `?` because it has type `Result<_, serde_json::Error>`
    |
note: `McpError` needs to implement `From<serde_json::Error>`
   --> src\mcp\error.rs:13:1
    |
13  | pub enum McpError {
    | ^^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait
    = help: the trait `From<serde_json::Error>` is not implemented for `McpError`
            but trait `From<JsonRpcError>` is implemented for it
    = help: for that trait implementation, expected `JsonRpcError`, found `serde_json::Error`

error[E0038]: the trait `Transport` is not dyn compatible
   --> src\mcp\client.rs:340:9
    |
340 |         self.transport.close().await?;
    |         ^^^^^^^^^^^^^^^^^^^^^^ `Transport` is not dyn compatible
    |
note: for a trait to be dyn compatible it needs to allow building a vtable
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
   --> src\mcp\transport\mod.rs:16:14
    |
14  | pub trait Transport: Send + Sync {
    |           --------- this trait is not dyn compatible...
15  |     /// Send a message through the transport
16  |     async fn send(&self, message: &str) -> McpResult<()>;
    |              ^^^^ ...because method `send` is `async`
...
19  |     async fn receive(&self) -> McpResult<String>;
    |              ^^^^^^^ ...because method `receive` is `async`
...
22  |     async fn close(&self) -> McpResult<()>;
    |              ^^^^^ ...because method `close` is `async`
    = help: consider moving `close` to another trait
    = help: consider moving `send` to another trait
    = help: consider moving `receive` to another trait
    = help: the following types implement `Transport`:
              mcp::transport::sse::SseTransport
              mcp::transport::stdio::StdioTransport
            consider defining an enum where each variant holds one of these types,
            implementing `Transport` for this new enum and using it instead

error[E0277]: `?` couldn't convert the error to `McpError`
   --> src\mcp\config.rs:116:60
    |
116 |         let content = serde_json::to_string_pretty(&config)?;
    |                       -------------------------------------^ the trait `From<serde_json::Error>` is not implemented for `McpError`
    |                       |
    |                       this can't be annotated with `?` because it has type `Result<_, serde_json::Error>`
    |
note: `McpError` needs to implement `From<serde_json::Error>`
   --> src\mcp\error.rs:13:1
    |
13  | pub enum McpError {
    | ^^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait
    = help: the trait `From<serde_json::Error>` is not implemented for `McpError`
            but trait `From<JsonRpcError>` is implemented for it
    = help: for that trait implementation, expected `JsonRpcError`, found `serde_json::Error`

error[E0599]: the method `to_string` exists for reference `&McpError`, but its trait bounds were not satisfied
    --> src\mcp\manager.rs:98:66
     |
98   |             instance.state.status = McpServerStatus::Error(error.to_string());
     |                                                                  ^^^^^^^^^ method cannot be called on `&McpError` due to unsatisfied trait bounds
     |
    ::: src\mcp\error.rs:13:1
     |
13   | pub enum McpError {
     | ----------------- doesn't satisfy `McpError: ToString` or `McpError: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `McpError: std::fmt::Display`
             which is required by `McpError: ToString`
             `&McpError: std::fmt::Display`
             which is required by `&McpError: ToString`
note: the trait `std::fmt::Display` must be implemented
    --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\fmt\mod.rs:1003:1
     |
1003 | pub trait Display: PointeeSized {
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following trait defines an item `to_string`, perhaps you need to implement it:
             candidate #1: `ToString`

error[E0599]: the method `to_string` exists for reference `&McpError`, but its trait bounds were not satisfied
    --> src\mcp\manager.rs:99:55
     |
99   |             instance.state.error_message = Some(error.to_string());
     |                                                       ^^^^^^^^^ method cannot be called on `&McpError` due to unsatisfied trait bounds
     |
    ::: src\mcp\error.rs:13:1
     |
13   | pub enum McpError {
     | ----------------- doesn't satisfy `McpError: ToString` or `McpError: std::fmt::Display`
     |
     = note: the following trait bounds were not satisfied:
             `McpError: std::fmt::Display`
             which is required by `McpError: ToString`
             `&McpError: std::fmt::Display`
             which is required by `&McpError: ToString`
note: the trait `std::fmt::Display` must be implemented
    --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\fmt\mod.rs:1003:1
     |
1003 | pub trait Display: PointeeSized {
     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     = help: items from traits can only be used if the trait is implemented and in scope
     = note: the following trait defines an item `to_string`, perhaps you need to implement it:
             candidate #1: `ToString`

error[E0277]: `McpError` doesn't implement `std::fmt::Display`
   --> src\mcp\manager.rs:174:71
    |
174 |                 log::error!("Failed to auto-start server {}: {}", id, e);
    |                                                              --       ^ `McpError` cannot be formatted with the default formatter
    |                                                              |
    |                                                              required by this formatting parameter
    |
    = help: the trait `std::fmt::Display` is not implemented for `McpError`
    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
    = note: this error originates in the macro `$crate::__private_api::format_args` which comes from the expansion of the macro `log::error` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
   --> src\mcp\manager.rs:573:20
    |
573 |         let task = tokio::spawn(async move {
    |                    ^^^^^ use of unresolved module or unlinked crate `tokio`
    |
    = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
   --> src\mcp\manager.rs:776:20
    |
776 |         let task = tokio::spawn(async move {
    |                    ^^^^^ use of unresolved module or unlinked crate `tokio`
    |
    = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`

error[E0277]: `McpError` doesn't implement `std::fmt::Display`
   --> src\mcp\manager.rs:810:78
    |
810 |                     log::error!("Reconnection failed for {}: {}", server_id, e);
    |                                                              --              ^ `McpError` cannot be formatted with the default formatter
    |                                                              |
    |                                                              required by this formatting parameter
    |
    = help: the trait `std::fmt::Display` is not implemented for `McpError`
    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
    = note: this error originates in the macro `$crate::__private_api::format_args` which comes from the expansion of the macro `log::error` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: `McpError` doesn't implement `std::fmt::Display`
   --> src\mcp\manager.rs:823:93
    |
823 |                     log::error!("Reconnection initialization failed for {}: {}", server_id, e);
    |                                                                             --              ^ `McpError` cannot be formatted with the default formatter
    |                                                                             |
    |                                                                             required by this formatting parameter
    |
    = help: the trait `std::fmt::Display` is not implemented for `McpError`
    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
    = note: this error originates in the macro `$crate::__private_api::format_args` which comes from the expansion of the macro `log::error` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
   --> src\mcp\manager.rs:858:30
    |
858 |             let notif_task = tokio::spawn(async move {
    |                              ^^^^^ use of unresolved module or unlinked crate `tokio`
    |
    = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`

error[E0277]: the size for values of type `str` cannot be known at compilation time
   --> src\mcp\manager.rs:923:13
    |
923 |         for id in server_ids {
    |             ^^ doesn't have a size known at compile-time
    |
    = help: the trait `Sized` is not implemented for `str`
    = note: all local variables must have a statically known size

error[E0277]: the size for values of type `str` cannot be known at compilation time
   --> src\mcp\manager.rs:923:9
    |
923 | /         for id in server_ids {
924 | |             if let Err(e) = self.disconnect_server(&id).await {
925 | |                 log::warn!("Failed to disconnect server {} during shutdown: {}", id, e);
926 | |             }
927 | |         }
    | |_________^ doesn't have a size known at compile-time
    |
    = help: the trait `Sized` is not implemented for `str`
note: required by a bound in `std::prelude::v1::None`
   --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\option.rs:591:17
    |
591 | pub enum Option<T> {
    |                 ^ required by this bound in `Option::None`
...
595 |     None,
    |     ---- required by a bound in this variant

error[E0277]: the size for values of type `str` cannot be known at compilation time
   --> src\mcp\manager.rs:923:19
    |
923 |         for id in server_ids {
    |                   ^^^^^^^^^^ doesn't have a size known at compile-time
    |
    = help: the trait `Sized` is not implemented for `str`
note: required by an implicit `Sized` bound in `std::option::Option`
   --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\option.rs:591:17
    |
591 | pub enum Option<T> {
    |                 ^ required by the implicit `Sized` requirement on this type parameter in `Option`

error[E0277]: the size for values of type `str` cannot be known at compilation time
   --> src\mcp\manager.rs:925:82
    |
925 |                 log::warn!("Failed to disconnect server {} during shutdown: {}", id, e);
    |                                                         --                       ^^ doesn't have a size known at compile-time
    |                                                         |
    |                                                         required by this formatting parameter
    |
    = help: the trait `Sized` is not implemented for `str`
    = note: this error originates in the macro `$crate::__private_api::format_args` which comes from the expansion of the macro `log::warn` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: `McpError` doesn't implement `std::fmt::Display`
   --> src\mcp\manager.rs:925:86
    |
925 |                 log::warn!("Failed to disconnect server {} during shutdown: {}", id, e);
    |                                                                             --       ^ `McpError` cannot be formatted with the default formatter
    |                                                                             |
    |                                                                             required by this formatting parameter
    |
    = help: the trait `std::fmt::Display` is not implemented for `McpError`
    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
    = note: this error originates in the macro `$crate::__private_api::format_args` which comes from the expansion of the macro `log::warn` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `tokio`
  --> src\mcp\transport\sse.rs:47:9
   |
47 |         tokio::spawn(async move {
   |         ^^^^^ use of unresolved module or unlinked crate `tokio`
   |
   = help: if you wanted to use a crate named `tokio`, use `cargo add tokio` to add it to your `Cargo.toml`

error[E0277]: `?` couldn't convert the error to `SandboxError`
   --> src\sandbox\docker.rs:166:43
    |
166 |         let temp_dir = tempfile::tempdir()?;
    |                        -------------------^ the trait `From<std::io::Error>` is not implemented for `SandboxError`
    |                        |
    |                        this can't be annotated with `?` because it has type `Result<_, std::io::Error>`
    |
note: `SandboxError` needs to implement `From<std::io::Error>`
   --> src\sandbox\runtime.rs:17:1
    |
17  | pub enum SandboxError {
    | ^^^^^^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `SandboxError`
   --> src\sandbox\native.rs:177:43
    |
177 |         let temp_dir = tempfile::tempdir()?;
    |                        -------------------^ the trait `From<std::io::Error>` is not implemented for `SandboxError`
    |                        |
    |                        this can't be annotated with `?` because it has type `Result<_, std::io::Error>`
    |
note: `SandboxError` needs to implement `From<std::io::Error>`
   --> src\sandbox\runtime.rs:17:1
    |
17  | pub enum SandboxError {
    | ^^^^^^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `SandboxError`
   --> src\sandbox\podman.rs:153:43
    |
153 |         let temp_dir = tempfile::tempdir()?;
    |                        -------------------^ the trait `From<std::io::Error>` is not implemented for `SandboxError`
    |                        |
    |                        this can't be annotated with `?` because it has type `Result<_, std::io::Error>`
    |
note: `SandboxError` needs to implement `From<std::io::Error>`
   --> src\sandbox\runtime.rs:17:1
    |
17  | pub enum SandboxError {
    | ^^^^^^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0038]: the trait `SandboxRuntime` is not dyn compatible
   --> src\sandbox\runtime.rs:400:14
    |
400 |             .get_runtime(request.runtime)
    |              ^^^^^^^^^^^ `SandboxRuntime` is not dyn compatible
    |
note: for a trait to be dyn compatible it needs to allow building a vtable
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
   --> src\sandbox\runtime.rs:250:14
    |
245 | pub trait SandboxRuntime: Send + Sync {
    |           -------------- this trait is not dyn compatible...
...
250 |     async fn is_available(&self) -> bool;
    |              ^^^^^^^^^^^^ ...because method `is_available` is `async`
...
253 |     async fn get_version(&self) -> Result<String, SandboxError>;
    |              ^^^^^^^^^^^ ...because method `get_version` is `async`
...
256 |     async fn execute(
    |              ^^^^^^^ ...because method `execute` is `async`
...
264 |     async fn cleanup(&self) -> Result<(), SandboxError>;
    |              ^^^^^^^ ...because method `cleanup` is `async`
...
267 |     async fn prepare_image(&self, language: &str) -> Result<(), SandboxError> {
    |              ^^^^^^^^^^^^^ ...because method `prepare_image` is `async`
    = help: consider moving `execute` to another trait
    = help: consider moving `is_available` to another trait
    = help: consider moving `get_version` to another trait
    = help: consider moving `cleanup` to another trait
    = help: consider moving `prepare_image` to another trait
    = help: the following types implement `SandboxRuntime`:
              sandbox::docker::DockerRuntime
              sandbox::native::NativeRuntime
              sandbox::podman::PodmanRuntime
            consider defining an enum where each variant holds one of these types,
            implementing `SandboxRuntime` for this new enum and using it instead

error[E0038]: the trait `SandboxRuntime` is not dyn compatible
   --> src\sandbox\runtime.rs:399:23
    |
399 |           let runtime = self
    |  _______________________^
400 | |             .get_runtime(request.runtime)
401 | |             .ok_or_else(|| SandboxError::RuntimeNotAvailable("No runtime available".to_string()))?;
    | |_________________________________________________________________________________________________^ `SandboxRuntime` is not dyn compatible
    |
note: for a trait to be dyn compatible it needs to allow building a vtable
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
   --> src\sandbox\runtime.rs:250:14
    |
245 | pub trait SandboxRuntime: Send + Sync {
    |           -------------- this trait is not dyn compatible...
...
250 |     async fn is_available(&self) -> bool;
    |              ^^^^^^^^^^^^ ...because method `is_available` is `async`
...
253 |     async fn get_version(&self) -> Result<String, SandboxError>;
    |              ^^^^^^^^^^^ ...because method `get_version` is `async`
...
256 |     async fn execute(
    |              ^^^^^^^ ...because method `execute` is `async`
...
264 |     async fn cleanup(&self) -> Result<(), SandboxError>;
    |              ^^^^^^^ ...because method `cleanup` is `async`
...
267 |     async fn prepare_image(&self, language: &str) -> Result<(), SandboxError> {
    |              ^^^^^^^^^^^^^ ...because method `prepare_image` is `async`
    = help: consider moving `execute` to another trait
    = help: consider moving `is_available` to another trait
    = help: consider moving `get_version` to another trait
    = help: consider moving `cleanup` to another trait
    = help: consider moving `prepare_image` to another trait
    = help: the following types implement `SandboxRuntime`:
              sandbox::docker::DockerRuntime
              sandbox::native::NativeRuntime
              sandbox::podman::PodmanRuntime
            consider defining an enum where each variant holds one of these types,
            implementing `SandboxRuntime` for this new enum and using it instead

error[E0038]: the trait `SandboxRuntime` is not dyn compatible
   --> src\sandbox\runtime.rs:399:23
    |
399 |           let runtime = self
    |  _______________________^
400 | |             .get_runtime(request.runtime)
401 | |             .ok_or_else(|| SandboxError::RuntimeNotAvailable("No runtime available".to_string()))?;
    | |__________________________________________________________________________________________________^ `SandboxRuntime` is not dyn compatible
    |
note: for a trait to be dyn compatible it needs to allow building a vtable
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
   --> src\sandbox\runtime.rs:250:14
    |
245 | pub trait SandboxRuntime: Send + Sync {
    |           -------------- this trait is not dyn compatible...
...
250 |     async fn is_available(&self) -> bool;
    |              ^^^^^^^^^^^^ ...because method `is_available` is `async`
...
253 |     async fn get_version(&self) -> Result<String, SandboxError>;
    |              ^^^^^^^^^^^ ...because method `get_version` is `async`
...
256 |     async fn execute(
    |              ^^^^^^^ ...because method `execute` is `async`
...
264 |     async fn cleanup(&self) -> Result<(), SandboxError>;
    |              ^^^^^^^ ...because method `cleanup` is `async`
...
267 |     async fn prepare_image(&self, language: &str) -> Result<(), SandboxError> {
    |              ^^^^^^^^^^^^^ ...because method `prepare_image` is `async`
    = help: consider moving `execute` to another trait
    = help: consider moving `is_available` to another trait
    = help: consider moving `get_version` to another trait
    = help: consider moving `cleanup` to another trait
    = help: consider moving `prepare_image` to another trait
    = help: the following types implement `SandboxRuntime`:
              sandbox::docker::DockerRuntime
              sandbox::native::NativeRuntime
              sandbox::podman::PodmanRuntime
            consider defining an enum where each variant holds one of these types,
            implementing `SandboxRuntime` for this new enum and using it instead

error[E0038]: the trait `SandboxRuntime` is not dyn compatible
   --> src\sandbox\runtime.rs:432:28
    |
432 |         let runtime = self.get_runtime_by_type(runtime_type)?;
    |                            ^^^^^^^^^^^^^^^^^^^ `SandboxRuntime` is not dyn compatible
    |
note: for a trait to be dyn compatible it needs to allow building a vtable
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
   --> src\sandbox\runtime.rs:250:14
    |
245 | pub trait SandboxRuntime: Send + Sync {
    |           -------------- this trait is not dyn compatible...
...
250 |     async fn is_available(&self) -> bool;
    |              ^^^^^^^^^^^^ ...because method `is_available` is `async`
...
253 |     async fn get_version(&self) -> Result<String, SandboxError>;
    |              ^^^^^^^^^^^ ...because method `get_version` is `async`
...
256 |     async fn execute(
    |              ^^^^^^^ ...because method `execute` is `async`
...
264 |     async fn cleanup(&self) -> Result<(), SandboxError>;
    |              ^^^^^^^ ...because method `cleanup` is `async`
...
267 |     async fn prepare_image(&self, language: &str) -> Result<(), SandboxError> {
    |              ^^^^^^^^^^^^^ ...because method `prepare_image` is `async`
    = help: consider moving `execute` to another trait
    = help: consider moving `is_available` to another trait
    = help: consider moving `get_version` to another trait
    = help: consider moving `cleanup` to another trait
    = help: consider moving `prepare_image` to another trait
    = help: the following types implement `SandboxRuntime`:
              sandbox::docker::DockerRuntime
              sandbox::native::NativeRuntime
              sandbox::podman::PodmanRuntime
            consider defining an enum where each variant holds one of these types,
            implementing `SandboxRuntime` for this new enum and using it instead

error[E0038]: the trait `SandboxRuntime` is not dyn compatible
   --> src\sandbox\runtime.rs:432:23
    |
432 |         let runtime = self.get_runtime_by_type(runtime_type)?;
    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `SandboxRuntime` is not dyn compatible
    |
note: for a trait to be dyn compatible it needs to allow building a vtable
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
   --> src\sandbox\runtime.rs:250:14
    |
245 | pub trait SandboxRuntime: Send + Sync {
    |           -------------- this trait is not dyn compatible...
...
250 |     async fn is_available(&self) -> bool;
    |              ^^^^^^^^^^^^ ...because method `is_available` is `async`
...
253 |     async fn get_version(&self) -> Result<String, SandboxError>;
    |              ^^^^^^^^^^^ ...because method `get_version` is `async`
...
256 |     async fn execute(
    |              ^^^^^^^ ...because method `execute` is `async`
...
264 |     async fn cleanup(&self) -> Result<(), SandboxError>;
    |              ^^^^^^^ ...because method `cleanup` is `async`
...
267 |     async fn prepare_image(&self, language: &str) -> Result<(), SandboxError> {
    |              ^^^^^^^^^^^^^ ...because method `prepare_image` is `async`
    = help: consider moving `execute` to another trait
    = help: consider moving `is_available` to another trait
    = help: consider moving `get_version` to another trait
    = help: consider moving `cleanup` to another trait
    = help: consider moving `prepare_image` to another trait
    = help: the following types implement `SandboxRuntime`:
              sandbox::docker::DockerRuntime
              sandbox::native::NativeRuntime
              sandbox::podman::PodmanRuntime
            consider defining an enum where each variant holds one of these types,
            implementing `SandboxRuntime` for this new enum and using it instead

error[E0038]: the trait `SandboxRuntime` is not dyn compatible
   --> src\sandbox\runtime.rs:432:23
    |
432 |         let runtime = self.get_runtime_by_type(runtime_type)?;
    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `SandboxRuntime` is not dyn compatible
    |
note: for a trait to be dyn compatible it needs to allow building a vtable
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
   --> src\sandbox\runtime.rs:250:14
    |
245 | pub trait SandboxRuntime: Send + Sync {
    |           -------------- this trait is not dyn compatible...
...
250 |     async fn is_available(&self) -> bool;
    |              ^^^^^^^^^^^^ ...because method `is_available` is `async`
...
253 |     async fn get_version(&self) -> Result<String, SandboxError>;
    |              ^^^^^^^^^^^ ...because method `get_version` is `async`
...
256 |     async fn execute(
    |              ^^^^^^^ ...because method `execute` is `async`
...
264 |     async fn cleanup(&self) -> Result<(), SandboxError>;
    |              ^^^^^^^ ...because method `cleanup` is `async`
...
267 |     async fn prepare_image(&self, language: &str) -> Result<(), SandboxError> {
    |              ^^^^^^^^^^^^^ ...because method `prepare_image` is `async`
    = help: consider moving `execute` to another trait
    = help: consider moving `is_available` to another trait
    = help: consider moving `get_version` to another trait
    = help: consider moving `cleanup` to another trait
    = help: consider moving `prepare_image` to another trait
    = help: the following types implement `SandboxRuntime`:
              sandbox::docker::DockerRuntime
              sandbox::native::NativeRuntime
              sandbox::podman::PodmanRuntime
            consider defining an enum where each variant holds one of these types,
            implementing `SandboxRuntime` for this new enum and using it instead

error[E0277]: `DbError` doesn't implement `std::fmt::Display`
   --> src\sandbox\mod.rs:173:92
    |
173 |             .map_err(|e| SandboxError::Config(format!("Failed to initialize database: {}", e)))?;
    |                                                                                       --   ^ `DbError` cannot be formatted with the default formatter
    |                                                                                       |
    |                                                                                       required by this formatting parameter
    |
    = help: the trait `std::fmt::Display` is not implemented for `DbError`
    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
    = note: this error originates in the macro `$crate::__export::format_args` which comes from the expansion of the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: `DbError` doesn't implement `std::fmt::Display`
   --> src\sandbox\mod.rs:247:71
    |
247 |                 log::warn!("Failed to save execution to history: {}", e);
    |                                                                  --   ^ `DbError` cannot be formatted with the default formatter
    |                                                                  |
    |                                                                  required by this formatting parameter
    |
    = help: the trait `std::fmt::Display` is not implemented for `DbError`
    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
    = note: this error originates in the macro `$crate::__private_api::format_args` which comes from the expansion of the macro `log::warn` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: `DbError` doesn't implement `std::fmt::Display`
   --> src\sandbox\mod.rs:324:87
    |
324 |             .map_err(|e| SandboxError::Config(format!("Failed to create session: {}", e)))?;
    |                                                                                  --   ^ `DbError` cannot be formatted with the default formatter
    |                                                                                  |
    |                                                                                  required by this formatting parameter
    |
    = help: the trait `std::fmt::Display` is not implemented for `DbError`
    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
    = note: this error originates in the macro `$crate::__export::format_args` which comes from the expansion of the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: the size for values of type `str` cannot be known at compilation time
   --> src\sandbox\mod.rs:350:16
    |
350 |         if let Some(id) = session_id {
    |                ^^^^^^^^ doesn't have a size known at compile-time
    |
    = help: the trait `Sized` is not implemented for `str`
note: required by a bound in `std::prelude::v1::Some`
   --> C:\Users\Max Qian\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\option.rs:591:17
    |
591 | pub enum Option<T> {
    |                 ^ required by this bound in `std::prelude::v1::Some`
...
599 |     Some(#[stable(feature = "rust1", since = "1.0.0")] T),
    |     ---- required by a bound in this tuple variant

error[E0277]: `DbError` doesn't implement `std::fmt::Display`
   --> src\sandbox\mod.rs:353:90
    |
353 |                 .map_err(|e| SandboxError::Config(format!("Failed to close session: {}", e)))?;
    |                                                                                     --   ^ `DbError` cannot be formatted with the default formatter
    |                                                                                     |
    |                                                                                     required by this formatting parameter
    |
    = help: the trait `std::fmt::Display` is not implemented for `DbError`
    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
    = note: this error originates in the macro `$crate::__export::format_args` which comes from the expansion of the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: `DbError` doesn't implement `std::fmt::Display`
   --> src\sandbox\mod.rs:366:86
    |
366 |             .map_err(|e| SandboxError::Config(format!("Failed to list sessions: {}", e)))
    |                                                                                 --   ^ `DbError` cannot be formatted with the default formatter
    |                                                                                 |
    |                                                                                 required by this formatting parameter
    |
    = help: the trait `std::fmt::Display` is not implemented for `DbError`
    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
    = note: this error originates in the macro `$crate::__export::format_args` which comes from the expansion of the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: `DbError` doesn't implement `std::fmt::Display`
   --> src\sandbox\mod.rs:373:84
    |
373 |             .map_err(|e| SandboxError::Config(format!("Failed to get session: {}", e)))
    |                                                                               --   ^ `DbError` cannot be formatted with the default formatter
    |                                                                               |
    |                                                                               required by this formatting parameter
    |
    = help: the trait `std::fmt::Display` is not implemented for `DbError`
    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
    = note: this error originates in the macro `$crate::__export::format_args` which comes from the expansion of the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: `DbError` doesn't implement `std::fmt::Display`
   --> src\sandbox\mod.rs:392:87
    |
392 |             .map_err(|e| SandboxError::Config(format!("Failed to delete session: {}", e)))
    |                                                                                  --   ^ `DbError` cannot be formatted with the default formatter
    |                                                                                  |
    |                                                                                  required by this formatting parameter
    |
    = help: the trait `std::fmt::Display` is not implemented for `DbError`
    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
    = note: this error originates in the macro `$crate::__export::format_args` which comes from the expansion of the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: `DbError` doesn't implement `std::fmt::Display`
   --> src\sandbox\mod.rs:401:86
    |
401 |             .map_err(|e| SandboxError::Config(format!("Failed to get execution: {}", e)))
    |                                                                                 --   ^ `DbError` cannot be formatted with the default formatter
    |                                                                                 |
    |                                                                                 required by this formatting parameter
    |
    = help: the trait `std::fmt::Display` is not implemented for `DbError`
    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
    = note: this error originates in the macro `$crate::__export::format_args` which comes from the expansion of the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: `DbError` doesn't implement `std::fmt::Display`
   --> src\sandbox\mod.rs:411:89
    |
411 |             .map_err(|e| SandboxError::Config(format!("Failed to query executions: {}", e)))
    |                                                                                    --   ^ `DbError` cannot be formatted with the default formatter
    |                                                                                    |
    |                                                                                    required by this formatting parameter
    |
    = help: the trait `std::fmt::Display` is not implemented for `DbError`
    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
    = note: this error originates in the macro `$crate::__export::format_args` which comes from the expansion of the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: `DbError` doesn't implement `std::fmt::Display`
   --> src\sandbox\mod.rs:430:89
    |
430 |             .map_err(|e| SandboxError::Config(format!("Failed to delete execution: {}", e)))
    |                                                                                    --   ^ `DbError` cannot be formatted with the default formatter
    |                                                                                    |
    |                                                                                    required by this formatting parameter
    |
    = help: the trait `std::fmt::Display` is not implemented for `DbError`
    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
    = note: this error originates in the macro `$crate::__export::format_args` which comes from the expansion of the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: `DbError` doesn't implement `std::fmt::Display`
   --> src\sandbox\mod.rs:437:88
    |
437 |             .map_err(|e| SandboxError::Config(format!("Failed to toggle favorite: {}", e)))
    |                                                                                   --   ^ `DbError` cannot be formatted with the default formatter
    |                                                                                   |
    |                                                                                   required by this formatting parameter
    |
    = help: the trait `std::fmt::Display` is not implemented for `DbError`
    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
    = note: this error originates in the macro `$crate::__export::format_args` which comes from the expansion of the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: `DbError` doesn't implement `std::fmt::Display`
   --> src\sandbox\mod.rs:444:81
    |
444 |             .map_err(|e| SandboxError::Config(format!("Failed to add tags: {}", e)))
    |                                                                            --   ^ `DbError` cannot be formatted with the default formatter
    |                                                                            |
    |                                                                            required by this formatting parameter
    |
    = help: the trait `std::fmt::Display` is not implemented for `DbError`
    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
    = note: this error originates in the macro `$crate::__export::format_args` which comes from the expansion of the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: `DbError` doesn't implement `std::fmt::Display`
   --> src\sandbox\mod.rs:455:84
    |
455 |             .map_err(|e| SandboxError::Config(format!("Failed to remove tags: {}", e)))
    |                                                                               --   ^ `DbError` cannot be formatted with the default formatter
    |                                                                               |
    |                                                                               required by this formatting parameter
    |
    = help: the trait `std::fmt::Display` is not implemented for `DbError`
    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
    = note: this error originates in the macro `$crate::__export::format_args` which comes from the expansion of the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: `DbError` doesn't implement `std::fmt::Display`
   --> src\sandbox\mod.rs:465:86
    |
465 |             .map_err(|e| SandboxError::Config(format!("Failed to clear history: {}", e)))
    |                                                                                 --   ^ `DbError` cannot be formatted with the default formatter
    |                                                                                 |
    |                                                                                 required by this formatting parameter
    |
    = help: the trait `std::fmt::Display` is not implemented for `DbError`
    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
    = note: this error originates in the macro `$crate::__export::format_args` which comes from the expansion of the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: `DbError` doesn't implement `std::fmt::Display`
   --> src\sandbox\mod.rs:474:87
    |
474 |             .map_err(|e| SandboxError::Config(format!("Failed to create snippet: {}", e)))
    |                                                                                  --   ^ `DbError` cannot be formatted with the default formatter
    |                                                                                  |
    |                                                                                  required by this formatting parameter
    |
    = help: the trait `std::fmt::Display` is not implemented for `DbError`
    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
    = note: this error originates in the macro `$crate::__export::format_args` which comes from the expansion of the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: `DbError` doesn't implement `std::fmt::Display`
   --> src\sandbox\mod.rs:481:84
    |
481 |             .map_err(|e| SandboxError::Config(format!("Failed to get snippet: {}", e)))
    |                                                                               --   ^ `DbError` cannot be formatted with the default formatter
    |                                                                               |
    |                                                                               required by this formatting parameter
    |
    = help: the trait `std::fmt::Display` is not implemented for `DbError`
    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
    = note: this error originates in the macro `$crate::__export::format_args` which comes from the expansion of the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: `DbError` doesn't implement `std::fmt::Display`
   --> src\sandbox\mod.rs:491:87
    |
491 |             .map_err(|e| SandboxError::Config(format!("Failed to query snippets: {}", e)))
    |                                                                                  --   ^ `DbError` cannot be formatted with the default formatter
    |                                                                                  |
    |                                                                                  required by this formatting parameter
    |
    = help: the trait `std::fmt::Display` is not implemented for `DbError`
    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
    = note: this error originates in the macro `$crate::__export::format_args` which comes from the expansion of the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: `DbError` doesn't implement `std::fmt::Display`
   --> src\sandbox\mod.rs:498:87
    |
498 |             .map_err(|e| SandboxError::Config(format!("Failed to update snippet: {}", e)))
    |                                                                                  --   ^ `DbError` cannot be formatted with the default formatter
    |                                                                                  |
    |                                                                                  required by this formatting parameter
    |
    = help: the trait `std::fmt::Display` is not implemented for `DbError`
    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
    = note: this error originates in the macro `$crate::__export::format_args` which comes from the expansion of the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: `DbError` doesn't implement `std::fmt::Display`
   --> src\sandbox\mod.rs:505:87
    |
505 |             .map_err(|e| SandboxError::Config(format!("Failed to delete snippet: {}", e)))
    |                                                                                  --   ^ `DbError` cannot be formatted with the default formatter
    |                                                                                  |
    |                                                                                  required by this formatting parameter
    |
    = help: the trait `std::fmt::Display` is not implemented for `DbError`
    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
    = note: this error originates in the macro `$crate::__export::format_args` which comes from the expansion of the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: `DbError` doesn't implement `std::fmt::Display`
   --> src\sandbox\mod.rs:519:87
    |
519 |             .map_err(|e| SandboxError::Config(format!("Failed to create snippet: {}", e)))
    |                                                                                  --   ^ `DbError` cannot be formatted with the default formatter
    |                                                                                  |
    |                                                                                  required by this formatting parameter
    |
    = help: the trait `std::fmt::Display` is not implemented for `DbError`
    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
    = note: this error originates in the macro `$crate::__export::format_args` which comes from the expansion of the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: `DbError` doesn't implement `std::fmt::Display`
   --> src\sandbox\mod.rs:545:82
    |
545 |             .map_err(|e| SandboxError::Config(format!("Failed to get stats: {}", e)))
    |                                                                             --   ^ `DbError` cannot be formatted with the default formatter
    |                                                                             |
    |                                                                             required by this formatting parameter
    |
    = help: the trait `std::fmt::Display` is not implemented for `DbError`
    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
    = note: this error originates in the macro `$crate::__export::format_args` which comes from the expansion of the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: `DbError` doesn't implement `std::fmt::Display`
   --> src\sandbox\mod.rs:552:82
    |
552 |             .map_err(|e| SandboxError::Config(format!("Failed to get stats: {}", e)))
    |                                                                             --   ^ `DbError` cannot be formatted with the default formatter
    |                                                                             |
    |                                                                             required by this formatting parameter
    |
    = help: the trait `std::fmt::Display` is not implemented for `DbError`
    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
    = note: this error originates in the macro `$crate::__export::format_args` which comes from the expansion of the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: `DbError` doesn't implement `std::fmt::Display`
   --> src\sandbox\mod.rs:559:82
    |
559 |             .map_err(|e| SandboxError::Config(format!("Failed to get stats: {}", e)))
    |                                                                             --   ^ `DbError` cannot be formatted with the default formatter
    |                                                                             |
    |                                                                             required by this formatting parameter
    |
    = help: the trait `std::fmt::Display` is not implemented for `DbError`
    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
    = note: this error originates in the macro `$crate::__export::format_args` which comes from the expansion of the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: `DbError` doesn't implement `std::fmt::Display`
   --> src\sandbox\mod.rs:569:83
    |
569 |             .map_err(|e| SandboxError::Config(format!("Failed to get counts: {}", e)))
    |                                                                              --   ^ `DbError` cannot be formatted with the default formatter
    |                                                                              |
    |                                                                              required by this formatting parameter
    |
    = help: the trait `std::fmt::Display` is not implemented for `DbError`
    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
    = note: this error originates in the macro `$crate::__export::format_args` which comes from the expansion of the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: `DbError` doesn't implement `std::fmt::Display`
   --> src\sandbox\mod.rs:578:79
    |
578 |             .map_err(|e| SandboxError::Config(format!("Failed to export: {}", e)))
    |                                                                          --   ^ `DbError` cannot be formatted with the default formatter
    |                                                                          |
    |                                                                          required by this formatting parameter
    |
    = help: the trait `std::fmt::Display` is not implemented for `DbError`
    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
    = note: this error originates in the macro `$crate::__export::format_args` which comes from the expansion of the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: `DbError` doesn't implement `std::fmt::Display`
   --> src\sandbox\mod.rs:585:81
    |
585 |             .map_err(|e| SandboxError::Config(format!("Failed to get tags: {}", e)))
    |                                                                            --   ^ `DbError` cannot be formatted with the default formatter
    |                                                                            |
    |                                                                            required by this formatting parameter
    |
    = help: the trait `std::fmt::Display` is not implemented for `DbError`
    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
    = note: this error originates in the macro `$crate::__export::format_args` which comes from the expansion of the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: `DbError` doesn't implement `std::fmt::Display`
   --> src\sandbox\mod.rs:592:87
    |
592 |             .map_err(|e| SandboxError::Config(format!("Failed to get categories: {}", e)))
    |                                                                                  --   ^ `DbError` cannot be formatted with the default formatter
    |                                                                                  |
    |                                                                                  required by this formatting parameter
    |
    = help: the trait `std::fmt::Display` is not implemented for `DbError`
    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
    = note: this error originates in the macro `$crate::__export::format_args` which comes from the expansion of the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: `DbError` doesn't implement `std::fmt::Display`
   --> src\sandbox\mod.rs:599:81
    |
599 |             .map_err(|e| SandboxError::Config(format!("Failed to get size: {}", e)))
    |                                                                            --   ^ `DbError` cannot be formatted with the default formatter
    |                                                                            |
    |                                                                            required by this formatting parameter
    |
    = help: the trait `std::fmt::Display` is not implemented for `DbError`
    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
    = note: this error originates in the macro `$crate::__export::format_args` which comes from the expansion of the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: `DbError` doesn't implement `std::fmt::Display`
   --> src\sandbox\mod.rs:606:79
    |
606 |             .map_err(|e| SandboxError::Config(format!("Failed to vacuum: {}", e)))
    |                                                                          --   ^ `DbError` cannot be formatted with the default formatter
    |                                                                          |
    |                                                                          required by this formatting parameter
    |
    = help: the trait `std::fmt::Display` is not implemented for `DbError`
    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
    = note: this error originates in the macro `$crate::__export::format_args` which comes from the expansion of the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)

warning: unreachable statement
   --> src\selection\mod.rs:280:13
    |
178 | /             loop {
179 | |                 tokio::select! {
180 | |                     // Check for cancellation
181 | |                     _ = cancel_token.cancelled() => {
...   |
278 | |             }
    | |_____________- any code following this expression is unreachable
279 |               
280 |               log::info!("Selection event loop exited");
    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unreachable statement
    |
    = note: `#[warn(unreachable_code)]` on by default
    = note: this warning originates in the macro `$crate::log` which comes from the expansion of the macro `log::info` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0038]: the trait `Transport` is not dyn compatible
  --> src\mcp\client.rs:68:24
   |
68 |         transport: Arc<dyn Transport>,
   |                        ^^^^^^^^^^^^^ `Transport` is not dyn compatible
   |
note: for a trait to be dyn compatible it needs to allow building a vtable
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
  --> src\mcp\transport\mod.rs:16:14
   |
14 | pub trait Transport: Send + Sync {
   |           --------- this trait is not dyn compatible...
15 |     /// Send a message through the transport
16 |     async fn send(&self, message: &str) -> McpResult<()>;
   |              ^^^^ ...because method `send` is `async`
...
19 |     async fn receive(&self) -> McpResult<String>;
   |              ^^^^^^^ ...because method `receive` is `async`
...
22 |     async fn close(&self) -> McpResult<()>;
   |              ^^^^^ ...because method `close` is `async`
   = help: consider moving `close` to another trait
   = help: consider moving `send` to another trait
   = help: consider moving `receive` to another trait
   = help: the following types implement `Transport`:
             mcp::transport::sse::SseTransport
             mcp::transport::stdio::StdioTransport
           consider defining an enum where each variant holds one of these types,
           implementing `Transport` for this new enum and using it instead
help: you might have meant to use `Self` to refer to the implementing type
   |
68 -         transport: Arc<dyn Transport>,
68 +         transport: Arc<Self>,
   |

error[E0038]: the trait `SandboxRuntime` is not dyn compatible
   --> src\sandbox\runtime.rs:353:73
    |
353 |     fn get_runtime_by_type(&self, runtime_type: RuntimeType) -> Option<&dyn SandboxRuntime> {
    |                                                                         ^^^^^^^^^^^^^^^^^^ `SandboxRuntime` is not dyn compatible
    |
note: for a trait to be dyn compatible it needs to allow building a vtable
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
   --> src\sandbox\runtime.rs:250:14
    |
245 | pub trait SandboxRuntime: Send + Sync {
    |           -------------- this trait is not dyn compatible...
...
250 |     async fn is_available(&self) -> bool;
    |              ^^^^^^^^^^^^ ...because method `is_available` is `async`
...
253 |     async fn get_version(&self) -> Result<String, SandboxError>;
    |              ^^^^^^^^^^^ ...because method `get_version` is `async`
...
256 |     async fn execute(
    |              ^^^^^^^ ...because method `execute` is `async`
...
264 |     async fn cleanup(&self) -> Result<(), SandboxError>;
    |              ^^^^^^^ ...because method `cleanup` is `async`
...
267 |     async fn prepare_image(&self, language: &str) -> Result<(), SandboxError> {
    |              ^^^^^^^^^^^^^ ...because method `prepare_image` is `async`
    = help: consider moving `execute` to another trait
    = help: consider moving `is_available` to another trait
    = help: consider moving `get_version` to another trait
    = help: consider moving `cleanup` to another trait
    = help: consider moving `prepare_image` to another trait
    = help: the following types implement `SandboxRuntime`:
              sandbox::docker::DockerRuntime
              sandbox::native::NativeRuntime
              sandbox::podman::PodmanRuntime
            consider defining an enum where each variant holds one of these types,
            implementing `SandboxRuntime` for this new enum and using it instead
help: you might have meant to use `Self` to refer to the implementing type
    |
353 -     fn get_runtime_by_type(&self, runtime_type: RuntimeType) -> Option<&dyn SandboxRuntime> {
353 +     fn get_runtime_by_type(&self, runtime_type: RuntimeType) -> Option<&Self> {
    |

error[E0038]: the trait `SandboxRuntime` is not dyn compatible
   --> src\sandbox\runtime.rs:362:42
    |
362 |     fn get_any_runtime(&self) -> Option<&dyn SandboxRuntime> {
    |                                          ^^^^^^^^^^^^^^^^^^ `SandboxRuntime` is not dyn compatible
    |
note: for a trait to be dyn compatible it needs to allow building a vtable
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
   --> src\sandbox\runtime.rs:250:14
    |
245 | pub trait SandboxRuntime: Send + Sync {
    |           -------------- this trait is not dyn compatible...
...
250 |     async fn is_available(&self) -> bool;
    |              ^^^^^^^^^^^^ ...because method `is_available` is `async`
...
253 |     async fn get_version(&self) -> Result<String, SandboxError>;
    |              ^^^^^^^^^^^ ...because method `get_version` is `async`
...
256 |     async fn execute(
    |              ^^^^^^^ ...because method `execute` is `async`
...
264 |     async fn cleanup(&self) -> Result<(), SandboxError>;
    |              ^^^^^^^ ...because method `cleanup` is `async`
...
267 |     async fn prepare_image(&self, language: &str) -> Result<(), SandboxError> {
    |              ^^^^^^^^^^^^^ ...because method `prepare_image` is `async`
    = help: consider moving `execute` to another trait
    = help: consider moving `is_available` to another trait
    = help: consider moving `get_version` to another trait
    = help: consider moving `cleanup` to another trait
    = help: consider moving `prepare_image` to another trait
    = help: the following types implement `SandboxRuntime`:
              sandbox::docker::DockerRuntime
              sandbox::native::NativeRuntime
              sandbox::podman::PodmanRuntime
            consider defining an enum where each variant holds one of these types,
            implementing `SandboxRuntime` for this new enum and using it instead
help: you might have meant to use `Self` to refer to the implementing type
    |
362 -     fn get_any_runtime(&self) -> Option<&dyn SandboxRuntime> {
362 +     fn get_any_runtime(&self) -> Option<&Self> {
    |

error[E0038]: the trait `SandboxRuntime` is not dyn compatible
   --> src\sandbox\runtime.rs:369:70
    |
369 |     fn get_runtime(&self, preferred: Option<RuntimeType>) -> Option<&dyn SandboxRuntime> {
    |                                                                      ^^^^^^^^^^^^^^^^^^ `SandboxRuntime` is not dyn compatible
    |
note: for a trait to be dyn compatible it needs to allow building a vtable
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
   --> src\sandbox\runtime.rs:250:14
    |
245 | pub trait SandboxRuntime: Send + Sync {
    |           -------------- this trait is not dyn compatible...
...
250 |     async fn is_available(&self) -> bool;
    |              ^^^^^^^^^^^^ ...because method `is_available` is `async`
...
253 |     async fn get_version(&self) -> Result<String, SandboxError>;
    |              ^^^^^^^^^^^ ...because method `get_version` is `async`
...
256 |     async fn execute(
    |              ^^^^^^^ ...because method `execute` is `async`
...
264 |     async fn cleanup(&self) -> Result<(), SandboxError>;
    |              ^^^^^^^ ...because method `cleanup` is `async`
...
267 |     async fn prepare_image(&self, language: &str) -> Result<(), SandboxError> {
    |              ^^^^^^^^^^^^^ ...because method `prepare_image` is `async`
    = help: consider moving `execute` to another trait
    = help: consider moving `is_available` to another trait
    = help: consider moving `get_version` to another trait
    = help: consider moving `cleanup` to another trait
    = help: consider moving `prepare_image` to another trait
    = help: the following types implement `SandboxRuntime`:
              sandbox::docker::DockerRuntime
              sandbox::native::NativeRuntime
              sandbox::podman::PodmanRuntime
            consider defining an enum where each variant holds one of these types,
            implementing `SandboxRuntime` for this new enum and using it instead
help: you might have meant to use `Self` to refer to the implementing type
    |
369 -     fn get_runtime(&self, preferred: Option<RuntimeType>) -> Option<&dyn SandboxRuntime> {
369 +     fn get_runtime(&self, preferred: Option<RuntimeType>) -> Option<&Self> {
    |

error[E0038]: the trait `Transport` is not dyn compatible
  --> src\mcp\client.rs:74:13
   |
74 |             transport,
   |             ^^^^^^^^^ `Transport` is not dyn compatible
   |
note: for a trait to be dyn compatible it needs to allow building a vtable
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
  --> src\mcp\transport\mod.rs:16:14
   |
14 | pub trait Transport: Send + Sync {
   |           --------- this trait is not dyn compatible...
15 |     /// Send a message through the transport
16 |     async fn send(&self, message: &str) -> McpResult<()>;
   |              ^^^^ ...because method `send` is `async`
...
19 |     async fn receive(&self) -> McpResult<String>;
   |              ^^^^^^^ ...because method `receive` is `async`
...
22 |     async fn close(&self) -> McpResult<()>;
   |              ^^^^^ ...because method `close` is `async`
   = help: consider moving `close` to another trait
   = help: consider moving `send` to another trait
   = help: consider moving `receive` to another trait
   = help: the following types implement `Transport`:
             mcp::transport::sse::SseTransport
             mcp::transport::stdio::StdioTransport
           consider defining an enum where each variant holds one of these types,
           implementing `Transport` for this new enum and using it instead

error[E0038]: the trait `Transport` is not dyn compatible
   --> src\mcp\client.rs:351:9
    |
351 |         self.transport.is_connected()
    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `Transport` is not dyn compatible
    |
note: for a trait to be dyn compatible it needs to allow building a vtable
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
   --> src\mcp\transport\mod.rs:16:14
    |
14  | pub trait Transport: Send + Sync {
    |           --------- this trait is not dyn compatible...
15  |     /// Send a message through the transport
16  |     async fn send(&self, message: &str) -> McpResult<()>;
    |              ^^^^ ...because method `send` is `async`
...
19  |     async fn receive(&self) -> McpResult<String>;
    |              ^^^^^^^ ...because method `receive` is `async`
...
22  |     async fn close(&self) -> McpResult<()>;
    |              ^^^^^ ...because method `close` is `async`
    = help: consider moving `close` to another trait
    = help: consider moving `send` to another trait
    = help: consider moving `receive` to another trait
    = help: the following types implement `Transport`:
              mcp::transport::sse::SseTransport
              mcp::transport::stdio::StdioTransport
            consider defining an enum where each variant holds one of these types,
            implementing `Transport` for this new enum and using it instead

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:149:46
    |
149 |         let conn = Connection::open(&db_path)?;
    |                    --------------------------^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    |                    |
    |                    this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:160:48
    |
160 |         let conn = Connection::open_in_memory()?;
    |                    ----------------------------^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    |                    |
    |                    this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:258:10
    |
172 |           conn.execute_batch(
    |  ______________-
173 | |             r#"
174 | |             -- Execution history table
175 | |             CREATE TABLE IF NOT EXISTS executions (
...   |
257 | |             "#,
258 | |         )?;
    | |         -^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    | |_________|
    |           this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:303:10
    |
282 |           conn.execute(
    |  ______________-
283 | |             r#"INSERT INTO executions 
284 | |                (id, session_id, language, code, stdin, stdout, stderr, exit_code, 
285 | |                 status, runtime, execution_time_ms, memory_used_bytes, error, created_at, is_favorite)
...   |
302 | |             ],
303 | |         )?;
    | |         -^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    | |_________|
    |           this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:310:14
    |
307 |               conn.execute(
    |  __________________-
308 | |                 "INSERT OR IGNORE INTO execution_tags (execution_id, tag) VALUES (?1, ?2)",
309 | |                 params![result.id, tag],
310 | |             )?;
    | |             -^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    | |_____________|
    |               this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:318:14
    |
315 |               conn.execute(
    |  __________________-
316 | |                 "UPDATE sessions SET execution_count = execution_count + 1, updated_at = ?1 WHERE id = ?2",
317 | |                 params![now.to_rfc3339(), sid],
318 | |             )?;
    | |             -^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    | |_____________|
    |               this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:381:10
    |
359 |           conn.execute(
    |  ______________-
360 | |             r#"INSERT INTO language_stats 
361 | |                (language, total_executions, successful_executions, failed_executions, 
362 | |                 timeout_executions, total_execution_time_ms, total_memory_used_bytes, last_used)
...   |
380 | |             ],
381 | |         )?;
    | |         -^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    | |_________|
    |           this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:395:10
    |
390 |           let mut stmt = conn.prepare(
    |  _____________________________-
391 | |             r#"SELECT id, session_id, language, code, stdin, stdout, stderr, exit_code,
392 | |                       status, runtime, execution_time_ms, memory_used_bytes, error, 
393 | |                       created_at, is_favorite
394 | |                FROM executions WHERE id = ?1"#,
395 | |         )?;
    | |         -^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    | |_________|
    |           this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:414:36
    |
414 |         let id: String = row.get(0)?;
    |                              ------^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    |                              |
    |                              this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:415:44
    |
415 |         let status_str: String = row.get(8)?;
    |                                      ------^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    |                                      |
    |                                      this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:416:45
    |
416 |         let runtime_str: String = row.get(9)?;
    |                                       ------^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    |                                       |
    |                                       this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:417:49
    |
417 |         let created_at_str: String = row.get(13)?;
    |                                          -------^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    |                                          |
    |                                          this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:420:98
    |
420 |         let mut tag_stmt = conn.prepare("SELECT tag FROM execution_tags WHERE execution_id = ?1")?;
    |                                 -----------------------------------------------------------------^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    |                                 |
    |                                 this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:422:51
    |
422 |             .query_map(params![&id], |r| r.get(0))?
    |              -------------------------------------^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    |              |
    |              this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:445:35
    |
445 |             session_id: row.get(1)?,
    |                             ------^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    |                             |
    |                             this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:446:33
    |
446 |             language: row.get(2)?,
    |                           ------^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    |                           |
    |                           this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:447:29
    |
447 |             code: row.get(3)?,
    |                       ------^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    |                       |
    |                       this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:448:30
    |
448 |             stdin: row.get(4)?,
    |                        ------^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    |                        |
    |                        this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:449:31
    |
449 |             stdout: row.get(5)?,
    |                         ------^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    |                         |
    |                         this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:450:31
    |
450 |             stderr: row.get(6)?,
    |                         ------^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    |                         |
    |                         this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:451:34
    |
451 |             exit_code: row.get(7)?,
    |                            ------^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    |                            |
    |                            this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:454:53
    |
454 |             execution_time_ms: row.get::<_, i64>(10)? as u64,
    |                                    -----------------^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    |                                    |
    |                                    this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:455:61
    |
455 |             memory_used_bytes: row.get::<_, Option<i64>>(11)?.map(|v| v as u64),
    |                                    -------------------------^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    |                                    |
    |                                    this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:456:31
    |
456 |             error: row.get(12)?,
    |                        -------^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    |                        |
    |                        this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:461:47
    |
461 |             is_favorite: row.get::<_, i32>(14)? != 0,
    |                              -----------------^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    |                              |
    |                              this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:571:42
    |
571 |         let mut stmt = conn.prepare(&sql)?;
    |                             -------------^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    |                             |
    |                             this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:576:11
    |
574 |           let rows = stmt.query_map(params_refs.as_slice(), |row| {
    |  _________________________-
575 | |             Ok(self.row_to_execution_record(row, &conn))
576 | |         })?;
    | |          -^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    | |__________|
    |            this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:580:29
    |
580 |             results.push(row??);
    |                          ---^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    |                          |
    |                          this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:589:88
    |
589 |         let deleted = conn.execute("DELETE FROM executions WHERE id = ?1", params![id])?;
    |                            ------------------------------------------------------------^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    |                            |
    |                            this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:599:10
    |
596 |           conn.execute(
    |  ______________-
597 | |             "UPDATE executions SET is_favorite = CASE WHEN is_favorite = 0 THEN 1 ELSE 0 END WHERE id = ?1",
598 | |             params![id],
599 | |         )?;
    | |         -^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    | |_________|
    |           this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:605:10
    |
601 |           let is_favorite: i32 = conn.query_row(
    |  _____________________________________-
602 | |             "SELECT is_favorite FROM executions WHERE id = ?1",
603 | |             params![id],
604 | |             |row| row.get(0),
605 | |         )?;
    | |         -^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    | |_________|
    |           this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:617:14
    |
614 |               conn.execute(
    |  __________________-
615 | |                 "INSERT OR IGNORE INTO execution_tags (execution_id, tag) VALUES (?1, ?2)",
616 | |                 params![id, tag],
617 | |             )?;
    | |             -^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    | |_____________|
    |               this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:629:14
    |
626 |               conn.execute(
    |  __________________-
627 | |                 "DELETE FROM execution_tags WHERE execution_id = ?1 AND tag = ?2",
628 | |                 params![id, tag],
629 | |             )?;
    | |             -^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    | |_____________|
    |               this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:642:14
    |
639 |               conn.execute(
    |  __________________-
640 | |                 "DELETE FROM executions WHERE created_at < ?1 AND is_favorite = 0",
641 | |                 params![date.to_rfc3339()],
642 | |             )?
    | |             -^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    | |_____________|
    |               this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:644:77
    |
644 |             conn.execute("DELETE FROM executions WHERE is_favorite = 0", [])?
    |                  -----------------------------------------------------------^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    |                  |
    |                  this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:672:10
    |
656 |           conn.execute(
    |  ______________-
657 | |             r#"INSERT INTO snippets 
658 | |                (id, title, description, language, code, category, is_template, usage_count, created_at, updated_at)
659 | |                VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10)"#,
...   |
671 | |             ],
672 | |         )?;
    | |         -^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    | |_________|
    |           this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:679:14
    |
676 |               conn.execute(
    |  __________________-
677 | |                 "INSERT OR IGNORE INTO snippet_tags (snippet_id, tag) VALUES (?1, ?2)",
678 | |                 params![snippet.id, tag],
679 | |             )?;
    | |             -^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    | |_____________|
    |               this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:693:10
    |
689 |           let mut stmt = conn.prepare(
    |  _____________________________-
690 | |             r#"SELECT id, title, description, language, code, category, is_template, 
691 | |                       usage_count, created_at, updated_at
692 | |                FROM snippets WHERE id = ?1"#,
693 | |         )?;
    | |         -^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    | |_________|
    |           this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:706:36
    |
706 |         let id: String = row.get(0)?;
    |                              ------^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    |                              |
    |                              this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:707:48
    |
707 |         let created_at_str: String = row.get(8)?;
    |                                          ------^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    |                                          |
    |                                          this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:708:48
    |
708 |         let updated_at_str: String = row.get(9)?;
    |                                          ------^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    |                                          |
    |                                          this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:711:94
    |
711 |         let mut tag_stmt = conn.prepare("SELECT tag FROM snippet_tags WHERE snippet_id = ?1")?;
    |                                 -------------------------------------------------------------^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    |                                 |
    |                                 this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:713:51
    |
713 |             .query_map(params![&id], |r| r.get(0))?
    |              -------------------------------------^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    |              |
    |              this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:719:30
    |
719 |             title: row.get(1)?,
    |                        ------^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    |                        |
    |                        this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:720:36
    |
720 |             description: row.get(2)?,
    |                              ------^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    |                              |
    |                              this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:721:33
    |
721 |             language: row.get(3)?,
    |                           ------^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    |                           |
    |                           this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:722:29
    |
722 |             code: row.get(4)?,
    |                       ------^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    |                       |
    |                       this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:723:33
    |
723 |             category: row.get(5)?,
    |                           ------^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    |                           |
    |                           this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:724:46
    |
724 |             is_template: row.get::<_, i32>(6)? != 0,
    |                              ----------------^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    |                              |
    |                              this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:725:46
    |
725 |             usage_count: row.get::<_, i32>(7)? as u32,
    |                              ----------------^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    |                              |
    |                              this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:814:42
    |
814 |         let mut stmt = conn.prepare(&sql)?;
    |                             -------------^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    |                             |
    |                             this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:819:11
    |
817 |           let rows = stmt.query_map(params_refs.as_slice(), |row| {
    |  _________________________-
818 | |             Ok(self.row_to_snippet(row, &conn))
819 | |         })?;
    | |          -^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    | |__________|
    |            this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:823:29
    |
823 |             results.push(row??);
    |                          ---^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    |                          |
    |                          this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:849:10
    |
834 |           conn.execute(
    |  ______________-
835 | |             r#"UPDATE snippets 
836 | |                SET title = ?1, description = ?2, language = ?3, code = ?4, 
837 | |                    category = ?5, is_template = ?6, updated_at = ?7
...   |
848 | |             ],
849 | |         )?;
    | |         -^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    | |_________|
    |           this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:852:92
    |
852 |         conn.execute("DELETE FROM snippet_tags WHERE snippet_id = ?1", params![snippet.id])?;
    |              ------------------------------------------------------------------------------^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    |              |
    |              this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:857:14
    |
854 |               conn.execute(
    |  __________________-
855 | |                 "INSERT OR IGNORE INTO snippet_tags (snippet_id, tag) VALUES (?1, ?2)",
856 | |                 params![snippet.id, tag],
857 | |             )?;
    | |             -^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    | |_____________|
    |               this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:866:86
    |
866 |         let deleted = conn.execute("DELETE FROM snippets WHERE id = ?1", params![id])?;
    |                            ----------------------------------------------------------^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    |                            |
    |                            this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:876:10
    |
873 |           conn.execute(
    |  ______________-
874 | |             "UPDATE snippets SET usage_count = usage_count + 1, updated_at = ?1 WHERE id = ?2",
875 | |             params![Utc::now().to_rfc3339(), id],
876 | |         )?;
    | |         -^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    | |_________|
    |           this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:923:10
    |
919 |           conn.execute(
    |  ______________-
920 | |             r#"INSERT INTO sessions (id, name, description, created_at, updated_at, execution_count, is_active)
921 | |                VALUES (?1, ?2, ?3, ?4, ?5, 0, 1)"#,
922 | |             params![id, name, description, now.to_rfc3339(), now.to_rfc3339()],
923 | |         )?;
    | |         -^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    | |_________|
    |           this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:943:10
    |
940 |           let mut stmt = conn.prepare(
    |  _____________________________-
941 | |             r#"SELECT id, name, description, created_at, updated_at, execution_count, is_active
942 | |                FROM sessions WHERE id = ?1"#,
943 | |         )?;
    | |         -^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    | |_________|
    |           this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:981:41
    |
981 |         let mut stmt = conn.prepare(sql)?;
    |                             ------------^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    |                             |
    |                             this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
   --> src\sandbox\db.rs:999:11
    |
982 |           let rows = stmt.query_map([], |row| {
    |  _________________________-
983 | |             let created_at_str: String = row.get(3)?;
984 | |             let updated_at_str: String = row.get(4)?;
...   |
998 | |             })
999 | |         })?;
    | |          -^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
    | |__________|
    |            this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
    |
note: `DbError` needs to implement `From<rusqlite::Error>`
   --> src\sandbox\db.rs:16:1
    |
16  | pub enum DbError {
    | ^^^^^^^^^^^^^^^^
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
    --> src\sandbox\db.rs:1003:29
     |
1003 |             results.push(row?);
     |                          ---^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
     |                          |
     |                          this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
     |
note: `DbError` needs to implement `From<rusqlite::Error>`
    --> src\sandbox\db.rs:16:1
     |
16   | pub enum DbError {
     | ^^^^^^^^^^^^^^^^
     = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
    --> src\sandbox\db.rs:1016:10
     |
1013 |           conn.execute(
     |  ______________-
1014 | |             "UPDATE sessions SET name = ?1, description = ?2, updated_at = ?3 WHERE id = ?4",
1015 | |             params![name, description, Utc::now().to_rfc3339(), id],
1016 | |         )?;
     | |         -^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
     | |_________|
     |           this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
     |
note: `DbError` needs to implement `From<rusqlite::Error>`
    --> src\sandbox\db.rs:16:1
     |
16   | pub enum DbError {
     | ^^^^^^^^^^^^^^^^
     = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
    --> src\sandbox\db.rs:1026:10
     |
1023 |           conn.execute(
     |  ______________-
1024 | |             "UPDATE sessions SET is_active = 0, updated_at = ?1 WHERE id = ?2",
1025 | |             params![Utc::now().to_rfc3339(), id],
1026 | |         )?;
     | |         -^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
     | |_________|
     |           this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
     |
note: `DbError` needs to implement `From<rusqlite::Error>`
    --> src\sandbox\db.rs:16:1
     |
16   | pub enum DbError {
     | ^^^^^^^^^^^^^^^^
     = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
    --> src\sandbox\db.rs:1035:86
     |
1035 |             conn.execute("DELETE FROM executions WHERE session_id = ?1", params![id])?;
     |                  --------------------------------------------------------------------^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
     |                  |
     |                  this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
     |
note: `DbError` needs to implement `From<rusqlite::Error>`
    --> src\sandbox\db.rs:16:1
     |
16   | pub enum DbError {
     | ^^^^^^^^^^^^^^^^
     = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
    --> src\sandbox\db.rs:1037:103
     |
1037 |             conn.execute("UPDATE executions SET session_id = NULL WHERE session_id = ?1", params![id])?;
     |                  -------------------------------------------------------------------------------------^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
     |                  |
     |                  this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
     |
note: `DbError` needs to implement `From<rusqlite::Error>`
    --> src\sandbox\db.rs:16:1
     |
16   | pub enum DbError {
     | ^^^^^^^^^^^^^^^^
     = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
    --> src\sandbox\db.rs:1040:72
     |
1040 |         conn.execute("DELETE FROM sessions WHERE id = ?1", params![id])?;
     |              ----------------------------------------------------------^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
     |              |
     |              this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
     |
note: `DbError` needs to implement `From<rusqlite::Error>`
    --> src\sandbox\db.rs:16:1
     |
16   | pub enum DbError {
     | ^^^^^^^^^^^^^^^^
     = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
    --> src\sandbox\db.rs:1063:10
     |
1059 |           let mut stmt = conn.prepare(
     |  _____________________________-
1060 | |             r#"SELECT language, total_executions, successful_executions, failed_executions,
1061 | |                       timeout_executions, total_execution_time_ms, total_memory_used_bytes, last_used
1062 | |                FROM language_stats WHERE language = ?1"#,
1063 | |         )?;
     | |         -^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
     | |_________|
     |           this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
     |
note: `DbError` needs to implement `From<rusqlite::Error>`
    --> src\sandbox\db.rs:16:1
     |
16   | pub enum DbError {
     | ^^^^^^^^^^^^^^^^
     = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
    --> src\sandbox\db.rs:1105:10
     |
1101 |           let mut stmt = conn.prepare(
     |  _____________________________-
1102 | |             r#"SELECT language, total_executions, successful_executions, failed_executions,
1103 | |                       timeout_executions, total_execution_time_ms, total_memory_used_bytes, last_used
1104 | |                FROM language_stats ORDER BY total_executions DESC"#,
1105 | |         )?;
     | |         -^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
     | |_________|
     |           this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
     |
note: `DbError` needs to implement `From<rusqlite::Error>`
    --> src\sandbox\db.rs:16:1
     |
16   | pub enum DbError {
     | ^^^^^^^^^^^^^^^^
     = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
    --> src\sandbox\db.rs:1130:11
     |
1107 |           let rows = stmt.query_map([], |row| {
     |  _________________________-
1108 | |             let total: i64 = row.get(1)?;
1109 | |             let last_used_str: Option<String> = row.get(7)?;
...    |
1129 | |             })
1130 | |         })?;
     | |          -^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
     | |__________|
     |            this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
     |
note: `DbError` needs to implement `From<rusqlite::Error>`
    --> src\sandbox\db.rs:16:1
     |
16   | pub enum DbError {
     | ^^^^^^^^^^^^^^^^
     = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
    --> src\sandbox\db.rs:1134:29
     |
1134 |             results.push(row?);
     |                          ---^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
     |                          |
     |                          this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
     |
note: `DbError` needs to implement `From<rusqlite::Error>`
    --> src\sandbox\db.rs:16:1
     |
16   | pub enum DbError {
     | ^^^^^^^^^^^^^^^^
     = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
    --> src\sandbox\db.rs:1155:10
     |
1145 |           let (total, success, failed, timeout, time): (i64, i64, i64, i64, i64) = conn.query_row(
     |  _______________________________________________________________________________________-
1146 | |             r#"SELECT 
1147 | |                 COALESCE(SUM(total_executions), 0),
1148 | |                 COALESCE(SUM(successful_executions), 0),
...    |
1154 | |             |row| Ok((row.get(0)?, row.get(1)?, row.get(2)?, row.get(3)?, row.get(4)?)),
1155 | |         )?;
     | |         -^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
     | |_________|
     |           this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
     |
note: `DbError` needs to implement `From<rusqlite::Error>`
    --> src\sandbox\db.rs:16:1
     |
16   | pub enum DbError {
     | ^^^^^^^^^^^^^^^^
     = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
    --> src\sandbox\db.rs:1162:10
     |
1158 |           let total_snippets: i64 = conn.query_row(
     |  ________________________________________-
1159 | |             "SELECT COUNT(*) FROM snippets",
1160 | |             [],
1161 | |             |row| row.get(0),
1162 | |         )?;
     | |         -^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
     | |_________|
     |           this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
     |
note: `DbError` needs to implement `From<rusqlite::Error>`
    --> src\sandbox\db.rs:16:1
     |
16   | pub enum DbError {
     | ^^^^^^^^^^^^^^^^
     = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
    --> src\sandbox\db.rs:1169:10
     |
1165 |           let total_sessions: i64 = conn.query_row(
     |  ________________________________________-
1166 | |             "SELECT COUNT(*) FROM sessions",
1167 | |             [],
1168 | |             |row| row.get(0),
1169 | |         )?;
     | |         -^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
     | |_________|
     |           this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
     |
note: `DbError` needs to implement `From<rusqlite::Error>`
    --> src\sandbox\db.rs:16:1
     |
16   | pub enum DbError {
     | ^^^^^^^^^^^^^^^^
     = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
    --> src\sandbox\db.rs:1208:10
     |
1202 |           let mut stmt = conn.prepare(
     |  _____________________________-
1203 | |             r#"SELECT DATE(created_at) as date, COUNT(*) as count
1204 | |                FROM executions
1205 | |                WHERE created_at >= DATE('now', ?1)
1206 | |                GROUP BY DATE(created_at)
1207 | |                ORDER BY date DESC"#,
1208 | |         )?;
     | |         -^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
     | |_________|
     |           this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
     |
note: `DbError` needs to implement `From<rusqlite::Error>`
    --> src\sandbox\db.rs:16:1
     |
16   | pub enum DbError {
     | ^^^^^^^^^^^^^^^^
     = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
    --> src\sandbox\db.rs:1213:11
     |
1211 |           let rows = stmt.query_map(params![offset], |row| {
     |  _________________________-
1212 | |             Ok((row.get::<_, String>(0)?, row.get::<_, i64>(1)? as u64))
1213 | |         })?;
     | |          -^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
     | |__________|
     |            this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
     |
note: `DbError` needs to implement `From<rusqlite::Error>`
    --> src\sandbox\db.rs:16:1
     |
16   | pub enum DbError {
     | ^^^^^^^^^^^^^^^^
     = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
    --> src\sandbox\db.rs:1217:29
     |
1217 |             results.push(row?);
     |                          ---^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
     |                          |
     |                          this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
     |
note: `DbError` needs to implement `From<rusqlite::Error>`
    --> src\sandbox\db.rs:16:1
     |
16   | pub enum DbError {
     | ^^^^^^^^^^^^^^^^
     = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
    --> src\sandbox\db.rs:1251:10
     |
1247 |           let size: i64 = conn.query_row(
     |  ______________________________-
1248 | |             "SELECT page_count * page_size as size FROM pragma_page_count(), pragma_page_size()",
1249 | |             [],
1250 | |             |row| row.get(0),
1251 | |         )?;
     | |         -^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
     | |_________|
     |           this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
     |
note: `DbError` needs to implement `From<rusqlite::Error>`
    --> src\sandbox\db.rs:16:1
     |
16   | pub enum DbError {
     | ^^^^^^^^^^^^^^^^
     = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
    --> src\sandbox\db.rs:1258:35
     |
1258 |         conn.execute("VACUUM", [])?;
     |              ---------------------^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
     |              |
     |              this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
     |
note: `DbError` needs to implement `From<rusqlite::Error>`
    --> src\sandbox\db.rs:16:1
     |
16   | pub enum DbError {
     | ^^^^^^^^^^^^^^^^
     = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
    --> src\sandbox\db.rs:1268:79
     |
1268 |         let mut stmt = conn.prepare("SELECT DISTINCT tag FROM execution_tags")?;
     |                             --------------------------------------------------^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
     |                             |
     |                             this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
     |
note: `DbError` needs to implement `From<rusqlite::Error>`
    --> src\sandbox\db.rs:16:1
     |
16   | pub enum DbError {
     | ^^^^^^^^^^^^^^^^
     = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
    --> src\sandbox\db.rs:1269:69
     |
1269 |         let rows = stmt.query_map([], |row| row.get::<_, String>(0))?;
     |                         --------------------------------------------^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
     |                         |
     |                         this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
     |
note: `DbError` needs to implement `From<rusqlite::Error>`
    --> src\sandbox\db.rs:16:1
     |
16   | pub enum DbError {
     | ^^^^^^^^^^^^^^^^
     = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
    --> src\sandbox\db.rs:1274:77
     |
1274 |         let mut stmt = conn.prepare("SELECT DISTINCT tag FROM snippet_tags")?;
     |                             ------------------------------------------------^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
     |                             |
     |                             this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
     |
note: `DbError` needs to implement `From<rusqlite::Error>`
    --> src\sandbox\db.rs:16:1
     |
16   | pub enum DbError {
     | ^^^^^^^^^^^^^^^^
     = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
    --> src\sandbox\db.rs:1275:69
     |
1275 |         let rows = stmt.query_map([], |row| row.get::<_, String>(0))?;
     |                         --------------------------------------------^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
     |                         |
     |                         this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
     |
note: `DbError` needs to implement `From<rusqlite::Error>`
    --> src\sandbox\db.rs:16:1
     |
16   | pub enum DbError {
     | ^^^^^^^^^^^^^^^^
     = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
    --> src\sandbox\db.rs:1289:123
     |
1289 |         let mut stmt = conn.prepare("SELECT DISTINCT category FROM snippets WHERE category IS NOT NULL ORDER BY category")?;
     |                             ----------------------------------------------------------------------------------------------^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
     |                             |
     |                             this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
     |
note: `DbError` needs to implement `From<rusqlite::Error>`
    --> src\sandbox\db.rs:16:1
     |
16   | pub enum DbError {
     | ^^^^^^^^^^^^^^^^
     = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
    --> src\sandbox\db.rs:1290:69
     |
1290 |         let rows = stmt.query_map([], |row| row.get::<_, String>(0))?;
     |                         --------------------------------------------^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
     |                         |
     |                         this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
     |
note: `DbError` needs to implement `From<rusqlite::Error>`
    --> src\sandbox\db.rs:16:1
     |
16   | pub enum DbError {
     | ^^^^^^^^^^^^^^^^
     = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0277]: `?` couldn't convert the error to `DbError`
    --> src\sandbox\db.rs:1294:29
     |
1294 |             results.push(row?);
     |                          ---^ the trait `From<rusqlite::Error>` is not implemented for `DbError`
     |                          |
     |                          this can't be annotated with `?` because it has type `Result<_, rusqlite::Error>`
     |
note: `DbError` needs to implement `From<rusqlite::Error>`
    --> src\sandbox\db.rs:16:1
     |
16   | pub enum DbError {
     | ^^^^^^^^^^^^^^^^
     = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait

error[E0038]: the trait `SandboxRuntime` is not dyn compatible
   --> src\sandbox\runtime.rs:355:75
    |
355 |             RuntimeType::Docker => self.docker.as_ref().map(|r| r as &dyn SandboxRuntime),
    |                                                                           ^^^^^^^^^^^^^^ `SandboxRuntime` is not dyn compatible
    |
note: for a trait to be dyn compatible it needs to allow building a vtable
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
   --> src\sandbox\runtime.rs:250:14
    |
245 | pub trait SandboxRuntime: Send + Sync {
    |           -------------- this trait is not dyn compatible...
...
250 |     async fn is_available(&self) -> bool;
    |              ^^^^^^^^^^^^ ...because method `is_available` is `async`
...
253 |     async fn get_version(&self) -> Result<String, SandboxError>;
    |              ^^^^^^^^^^^ ...because method `get_version` is `async`
...
256 |     async fn execute(
    |              ^^^^^^^ ...because method `execute` is `async`
...
264 |     async fn cleanup(&self) -> Result<(), SandboxError>;
    |              ^^^^^^^ ...because method `cleanup` is `async`
...
267 |     async fn prepare_image(&self, language: &str) -> Result<(), SandboxError> {
    |              ^^^^^^^^^^^^^ ...because method `prepare_image` is `async`
    = help: consider moving `execute` to another trait
    = help: consider moving `is_available` to another trait
    = help: consider moving `get_version` to another trait
    = help: consider moving `cleanup` to another trait
    = help: consider moving `prepare_image` to another trait
    = help: the following types implement `SandboxRuntime`:
              sandbox::docker::DockerRuntime
              sandbox::native::NativeRuntime
              sandbox::podman::PodmanRuntime
            consider defining an enum where each variant holds one of these types,
            implementing `SandboxRuntime` for this new enum and using it instead

error[E0038]: the trait `SandboxRuntime` is not dyn compatible
   --> src\sandbox\runtime.rs:356:75
    |
356 |             RuntimeType::Podman => self.podman.as_ref().map(|r| r as &dyn SandboxRuntime),
    |                                                                           ^^^^^^^^^^^^^^ `SandboxRuntime` is not dyn compatible
    |
note: for a trait to be dyn compatible it needs to allow building a vtable
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
   --> src\sandbox\runtime.rs:250:14
    |
245 | pub trait SandboxRuntime: Send + Sync {
    |           -------------- this trait is not dyn compatible...
...
250 |     async fn is_available(&self) -> bool;
    |              ^^^^^^^^^^^^ ...because method `is_available` is `async`
...
253 |     async fn get_version(&self) -> Result<String, SandboxError>;
    |              ^^^^^^^^^^^ ...because method `get_version` is `async`
...
256 |     async fn execute(
    |              ^^^^^^^ ...because method `execute` is `async`
...
264 |     async fn cleanup(&self) -> Result<(), SandboxError>;
    |              ^^^^^^^ ...because method `cleanup` is `async`
...
267 |     async fn prepare_image(&self, language: &str) -> Result<(), SandboxError> {
    |              ^^^^^^^^^^^^^ ...because method `prepare_image` is `async`
    = help: consider moving `execute` to another trait
    = help: consider moving `is_available` to another trait
    = help: consider moving `get_version` to another trait
    = help: consider moving `cleanup` to another trait
    = help: consider moving `prepare_image` to another trait
    = help: the following types implement `SandboxRuntime`:
              sandbox::docker::DockerRuntime
              sandbox::native::NativeRuntime
              sandbox::podman::PodmanRuntime
            consider defining an enum where each variant holds one of these types,
            implementing `SandboxRuntime` for this new enum and using it instead

error[E0038]: the trait `SandboxRuntime` is not dyn compatible
   --> src\sandbox\runtime.rs:357:75
    |
357 |             RuntimeType::Native => self.native.as_ref().map(|r| r as &dyn SandboxRuntime),
    |                                                                           ^^^^^^^^^^^^^^ `SandboxRuntime` is not dyn compatible
    |
note: for a trait to be dyn compatible it needs to allow building a vtable
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
   --> src\sandbox\runtime.rs:250:14
    |
245 | pub trait SandboxRuntime: Send + Sync {
    |           -------------- this trait is not dyn compatible...
...
250 |     async fn is_available(&self) -> bool;
    |              ^^^^^^^^^^^^ ...because method `is_available` is `async`
...
253 |     async fn get_version(&self) -> Result<String, SandboxError>;
    |              ^^^^^^^^^^^ ...because method `get_version` is `async`
...
256 |     async fn execute(
    |              ^^^^^^^ ...because method `execute` is `async`
...
264 |     async fn cleanup(&self) -> Result<(), SandboxError>;
    |              ^^^^^^^ ...because method `cleanup` is `async`
...
267 |     async fn prepare_image(&self, language: &str) -> Result<(), SandboxError> {
    |              ^^^^^^^^^^^^^ ...because method `prepare_image` is `async`
    = help: consider moving `execute` to another trait
    = help: consider moving `is_available` to another trait
    = help: consider moving `get_version` to another trait
    = help: consider moving `cleanup` to another trait
    = help: consider moving `prepare_image` to another trait
    = help: the following types implement `SandboxRuntime`:
              sandbox::docker::DockerRuntime
              sandbox::native::NativeRuntime
              sandbox::podman::PodmanRuntime
            consider defining an enum where each variant holds one of these types,
            implementing `SandboxRuntime` for this new enum and using it instead

error[E0038]: the trait `SandboxRuntime` is not dyn compatible
   --> src\sandbox\runtime.rs:363:14
    |
363 |         self.get_runtime_by_type(RuntimeType::Docker)
    |              ^^^^^^^^^^^^^^^^^^^ `SandboxRuntime` is not dyn compatible
    |
note: for a trait to be dyn compatible it needs to allow building a vtable
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
   --> src\sandbox\runtime.rs:250:14
    |
245 | pub trait SandboxRuntime: Send + Sync {
    |           -------------- this trait is not dyn compatible...
...
250 |     async fn is_available(&self) -> bool;
    |              ^^^^^^^^^^^^ ...because method `is_available` is `async`
...
253 |     async fn get_version(&self) -> Result<String, SandboxError>;
    |              ^^^^^^^^^^^ ...because method `get_version` is `async`
...
256 |     async fn execute(
    |              ^^^^^^^ ...because method `execute` is `async`
...
264 |     async fn cleanup(&self) -> Result<(), SandboxError>;
    |              ^^^^^^^ ...because method `cleanup` is `async`
...
267 |     async fn prepare_image(&self, language: &str) -> Result<(), SandboxError> {
    |              ^^^^^^^^^^^^^ ...because method `prepare_image` is `async`
    = help: consider moving `execute` to another trait
    = help: consider moving `is_available` to another trait
    = help: consider moving `get_version` to another trait
    = help: consider moving `cleanup` to another trait
    = help: consider moving `prepare_image` to another trait
    = help: the following types implement `SandboxRuntime`:
              sandbox::docker::DockerRuntime
              sandbox::native::NativeRuntime
              sandbox::podman::PodmanRuntime
            consider defining an enum where each variant holds one of these types,
            implementing `SandboxRuntime` for this new enum and using it instead

error[E0038]: the trait `SandboxRuntime` is not dyn compatible
   --> src\sandbox\runtime.rs:363:9
    |
363 | /         self.get_runtime_by_type(RuntimeType::Docker)
364 | |             .or_else(|| self.get_runtime_by_type(RuntimeType::Podman))
    | |______________________________________________________________________^ `SandboxRuntime` is not dyn compatible
    |
note: for a trait to be dyn compatible it needs to allow building a vtable
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
   --> src\sandbox\runtime.rs:250:14
    |
245 | pub trait SandboxRuntime: Send + Sync {
    |           -------------- this trait is not dyn compatible...
...
250 |     async fn is_available(&self) -> bool;
    |              ^^^^^^^^^^^^ ...because method `is_available` is `async`
...
253 |     async fn get_version(&self) -> Result<String, SandboxError>;
    |              ^^^^^^^^^^^ ...because method `get_version` is `async`
...
256 |     async fn execute(
    |              ^^^^^^^ ...because method `execute` is `async`
...
264 |     async fn cleanup(&self) -> Result<(), SandboxError>;
    |              ^^^^^^^ ...because method `cleanup` is `async`
...
267 |     async fn prepare_image(&self, language: &str) -> Result<(), SandboxError> {
    |              ^^^^^^^^^^^^^ ...because method `prepare_image` is `async`
    = help: consider moving `execute` to another trait
    = help: consider moving `is_available` to another trait
    = help: consider moving `get_version` to another trait
    = help: consider moving `cleanup` to another trait
    = help: consider moving `prepare_image` to another trait
    = help: the following types implement `SandboxRuntime`:
              sandbox::docker::DockerRuntime
              sandbox::native::NativeRuntime
              sandbox::podman::PodmanRuntime
            consider defining an enum where each variant holds one of these types,
            implementing `SandboxRuntime` for this new enum and using it instead

error[E0038]: the trait `SandboxRuntime` is not dyn compatible
   --> src\sandbox\runtime.rs:364:30
    |
364 |             .or_else(|| self.get_runtime_by_type(RuntimeType::Podman))
    |                              ^^^^^^^^^^^^^^^^^^^ `SandboxRuntime` is not dyn compatible
    |
note: for a trait to be dyn compatible it needs to allow building a vtable
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
   --> src\sandbox\runtime.rs:250:14
    |
245 | pub trait SandboxRuntime: Send + Sync {
    |           -------------- this trait is not dyn compatible...
...
250 |     async fn is_available(&self) -> bool;
    |              ^^^^^^^^^^^^ ...because method `is_available` is `async`
...
253 |     async fn get_version(&self) -> Result<String, SandboxError>;
    |              ^^^^^^^^^^^ ...because method `get_version` is `async`
...
256 |     async fn execute(
    |              ^^^^^^^ ...because method `execute` is `async`
...
264 |     async fn cleanup(&self) -> Result<(), SandboxError>;
    |              ^^^^^^^ ...because method `cleanup` is `async`
...
267 |     async fn prepare_image(&self, language: &str) -> Result<(), SandboxError> {
    |              ^^^^^^^^^^^^^ ...because method `prepare_image` is `async`
    = help: consider moving `execute` to another trait
    = help: consider moving `is_available` to another trait
    = help: consider moving `get_version` to another trait
    = help: consider moving `cleanup` to another trait
    = help: consider moving `prepare_image` to another trait
    = help: the following types implement `SandboxRuntime`:
              sandbox::docker::DockerRuntime
              sandbox::native::NativeRuntime
              sandbox::podman::PodmanRuntime
            consider defining an enum where each variant holds one of these types,
            implementing `SandboxRuntime` for this new enum and using it instead

error[E0038]: the trait `SandboxRuntime` is not dyn compatible
   --> src\sandbox\runtime.rs:363:9
    |
363 | /         self.get_runtime_by_type(RuntimeType::Docker)
364 | |             .or_else(|| self.get_runtime_by_type(RuntimeType::Podman))
365 | |             .or_else(|| self.get_runtime_by_type(RuntimeType::Native))
    | |______________________________________________________________________^ `SandboxRuntime` is not dyn compatible
    |
note: for a trait to be dyn compatible it needs to allow building a vtable
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
   --> src\sandbox\runtime.rs:250:14
    |
245 | pub trait SandboxRuntime: Send + Sync {
    |           -------------- this trait is not dyn compatible...
...
250 |     async fn is_available(&self) -> bool;
    |              ^^^^^^^^^^^^ ...because method `is_available` is `async`
...
253 |     async fn get_version(&self) -> Result<String, SandboxError>;
    |              ^^^^^^^^^^^ ...because method `get_version` is `async`
...
256 |     async fn execute(
    |              ^^^^^^^ ...because method `execute` is `async`
...
264 |     async fn cleanup(&self) -> Result<(), SandboxError>;
    |              ^^^^^^^ ...because method `cleanup` is `async`
...
267 |     async fn prepare_image(&self, language: &str) -> Result<(), SandboxError> {
    |              ^^^^^^^^^^^^^ ...because method `prepare_image` is `async`
    = help: consider moving `execute` to another trait
    = help: consider moving `is_available` to another trait
    = help: consider moving `get_version` to another trait
    = help: consider moving `cleanup` to another trait
    = help: consider moving `prepare_image` to another trait
    = help: the following types implement `SandboxRuntime`:
              sandbox::docker::DockerRuntime
              sandbox::native::NativeRuntime
              sandbox::podman::PodmanRuntime
            consider defining an enum where each variant holds one of these types,
            implementing `SandboxRuntime` for this new enum and using it instead

error[E0038]: the trait `SandboxRuntime` is not dyn compatible
   --> src\sandbox\runtime.rs:365:30
    |
365 |             .or_else(|| self.get_runtime_by_type(RuntimeType::Native))
    |                              ^^^^^^^^^^^^^^^^^^^ `SandboxRuntime` is not dyn compatible
    |
note: for a trait to be dyn compatible it needs to allow building a vtable
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
   --> src\sandbox\runtime.rs:250:14
    |
245 | pub trait SandboxRuntime: Send + Sync {
    |           -------------- this trait is not dyn compatible...
...
250 |     async fn is_available(&self) -> bool;
    |              ^^^^^^^^^^^^ ...because method `is_available` is `async`
...
253 |     async fn get_version(&self) -> Result<String, SandboxError>;
    |              ^^^^^^^^^^^ ...because method `get_version` is `async`
...
256 |     async fn execute(
    |              ^^^^^^^ ...because method `execute` is `async`
...
264 |     async fn cleanup(&self) -> Result<(), SandboxError>;
    |              ^^^^^^^ ...because method `cleanup` is `async`
...
267 |     async fn prepare_image(&self, language: &str) -> Result<(), SandboxError> {
    |              ^^^^^^^^^^^^^ ...because method `prepare_image` is `async`
    = help: consider moving `execute` to another trait
    = help: consider moving `is_available` to another trait
    = help: consider moving `get_version` to another trait
    = help: consider moving `cleanup` to another trait
    = help: consider moving `prepare_image` to another trait
    = help: the following types implement `SandboxRuntime`:
              sandbox::docker::DockerRuntime
              sandbox::native::NativeRuntime
              sandbox::podman::PodmanRuntime
            consider defining an enum where each variant holds one of these types,
            implementing `SandboxRuntime` for this new enum and using it instead

error[E0038]: the trait `SandboxRuntime` is not dyn compatible
   --> src\sandbox\runtime.rs:372:41
    |
372 |             if let Some(runtime) = self.get_runtime_by_type(pref) {
    |                                         ^^^^^^^^^^^^^^^^^^^ `SandboxRuntime` is not dyn compatible
    |
note: for a trait to be dyn compatible it needs to allow building a vtable
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
   --> src\sandbox\runtime.rs:250:14
    |
245 | pub trait SandboxRuntime: Send + Sync {
    |           -------------- this trait is not dyn compatible...
...
250 |     async fn is_available(&self) -> bool;
    |              ^^^^^^^^^^^^ ...because method `is_available` is `async`
...
253 |     async fn get_version(&self) -> Result<String, SandboxError>;
    |              ^^^^^^^^^^^ ...because method `get_version` is `async`
...
256 |     async fn execute(
    |              ^^^^^^^ ...because method `execute` is `async`
...
264 |     async fn cleanup(&self) -> Result<(), SandboxError>;
    |              ^^^^^^^ ...because method `cleanup` is `async`
...
267 |     async fn prepare_image(&self, language: &str) -> Result<(), SandboxError> {
    |              ^^^^^^^^^^^^^ ...because method `prepare_image` is `async`
    = help: consider moving `execute` to another trait
    = help: consider moving `is_available` to another trait
    = help: consider moving `get_version` to another trait
    = help: consider moving `cleanup` to another trait
    = help: consider moving `prepare_image` to another trait
    = help: the following types implement `SandboxRuntime`:
              sandbox::docker::DockerRuntime
              sandbox::native::NativeRuntime
              sandbox::podman::PodmanRuntime
            consider defining an enum where each variant holds one of these types,
            implementing `SandboxRuntime` for this new enum and using it instead

error[E0038]: the trait `SandboxRuntime` is not dyn compatible
   --> src\sandbox\runtime.rs:373:24
    |
373 |                 return Some(runtime);
    |                        ^^^^ `SandboxRuntime` is not dyn compatible
    |
note: for a trait to be dyn compatible it needs to allow building a vtable
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
   --> src\sandbox\runtime.rs:250:14
    |
245 | pub trait SandboxRuntime: Send + Sync {
    |           -------------- this trait is not dyn compatible...
...
250 |     async fn is_available(&self) -> bool;
    |              ^^^^^^^^^^^^ ...because method `is_available` is `async`
...
253 |     async fn get_version(&self) -> Result<String, SandboxError>;
    |              ^^^^^^^^^^^ ...because method `get_version` is `async`
...
256 |     async fn execute(
    |              ^^^^^^^ ...because method `execute` is `async`
...
264 |     async fn cleanup(&self) -> Result<(), SandboxError>;
    |              ^^^^^^^ ...because method `cleanup` is `async`
...
267 |     async fn prepare_image(&self, language: &str) -> Result<(), SandboxError> {
    |              ^^^^^^^^^^^^^ ...because method `prepare_image` is `async`
    = help: consider moving `execute` to another trait
    = help: consider moving `is_available` to another trait
    = help: consider moving `get_version` to another trait
    = help: consider moving `cleanup` to another trait
    = help: consider moving `prepare_image` to another trait
    = help: the following types implement `SandboxRuntime`:
              sandbox::docker::DockerRuntime
              sandbox::native::NativeRuntime
              sandbox::podman::PodmanRuntime
            consider defining an enum where each variant holds one of these types,
            implementing `SandboxRuntime` for this new enum and using it instead

error[E0038]: the trait `SandboxRuntime` is not dyn compatible
   --> src\sandbox\runtime.rs:373:24
    |
373 |                 return Some(runtime);
    |                        ^^^^^^^^^^^^^ `SandboxRuntime` is not dyn compatible
    |
note: for a trait to be dyn compatible it needs to allow building a vtable
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
   --> src\sandbox\runtime.rs:250:14
    |
245 | pub trait SandboxRuntime: Send + Sync {
    |           -------------- this trait is not dyn compatible...
...
250 |     async fn is_available(&self) -> bool;
    |              ^^^^^^^^^^^^ ...because method `is_available` is `async`
...
253 |     async fn get_version(&self) -> Result<String, SandboxError>;
    |              ^^^^^^^^^^^ ...because method `get_version` is `async`
...
256 |     async fn execute(
    |              ^^^^^^^ ...because method `execute` is `async`
...
264 |     async fn cleanup(&self) -> Result<(), SandboxError>;
    |              ^^^^^^^ ...because method `cleanup` is `async`
...
267 |     async fn prepare_image(&self, language: &str) -> Result<(), SandboxError> {
    |              ^^^^^^^^^^^^^ ...because method `prepare_image` is `async`
    = help: consider moving `execute` to another trait
    = help: consider moving `is_available` to another trait
    = help: consider moving `get_version` to another trait
    = help: consider moving `cleanup` to another trait
    = help: consider moving `prepare_image` to another trait
    = help: the following types implement `SandboxRuntime`:
              sandbox::docker::DockerRuntime
              sandbox::native::NativeRuntime
              sandbox::podman::PodmanRuntime
            consider defining an enum where each variant holds one of these types,
            implementing `SandboxRuntime` for this new enum and using it instead

error[E0038]: the trait `SandboxRuntime` is not dyn compatible
   --> src\sandbox\runtime.rs:378:9
    |
378 | /         self.get_runtime_by_type(self.config.preferred_runtime)
379 | |             .or_else(|| self.get_any_runtime())
    | |_______________________________________________^ `SandboxRuntime` is not dyn compatible
    |
note: for a trait to be dyn compatible it needs to allow building a vtable
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
   --> src\sandbox\runtime.rs:250:14
    |
245 | pub trait SandboxRuntime: Send + Sync {
    |           -------------- this trait is not dyn compatible...
...
250 |     async fn is_available(&self) -> bool;
    |              ^^^^^^^^^^^^ ...because method `is_available` is `async`
...
253 |     async fn get_version(&self) -> Result<String, SandboxError>;
    |              ^^^^^^^^^^^ ...because method `get_version` is `async`
...
256 |     async fn execute(
    |              ^^^^^^^ ...because method `execute` is `async`
...
264 |     async fn cleanup(&self) -> Result<(), SandboxError>;
    |              ^^^^^^^ ...because method `cleanup` is `async`
...
267 |     async fn prepare_image(&self, language: &str) -> Result<(), SandboxError> {
    |              ^^^^^^^^^^^^^ ...because method `prepare_image` is `async`
    = help: consider moving `execute` to another trait
    = help: consider moving `is_available` to another trait
    = help: consider moving `get_version` to another trait
    = help: consider moving `cleanup` to another trait
    = help: consider moving `prepare_image` to another trait
    = help: the following types implement `SandboxRuntime`:
              sandbox::docker::DockerRuntime
              sandbox::native::NativeRuntime
              sandbox::podman::PodmanRuntime
            consider defining an enum where each variant holds one of these types,
            implementing `SandboxRuntime` for this new enum and using it instead

error[E0038]: the trait `SandboxRuntime` is not dyn compatible
   --> src\sandbox\runtime.rs:379:30
    |
379 |             .or_else(|| self.get_any_runtime())
    |                              ^^^^^^^^^^^^^^^ `SandboxRuntime` is not dyn compatible
    |
note: for a trait to be dyn compatible it needs to allow building a vtable
      for more information, visit <https://doc.rust-lang.org/reference/items/traits.html#dyn-compatibility>
   --> src\sandbox\runtime.rs:250:14
    |
245 | pub trait SandboxRuntime: Send + Sync {
    |           -------------- this trait is not dyn compatible...
...
250 |     async fn is_available(&self) -> bool;
    |              ^^^^^^^^^^^^ ...because method `is_available` is `async`
...
253 |     async fn get_version(&self) -> Result<String, SandboxError>;
    |              ^^^^^^^^^^^ ...because method `get_version` is `async`
...
256 |     async fn execute(
    |              ^^^^^^^ ...because method `execute` is `async`
...
264 |     async fn cleanup(&self) -> Result<(), SandboxError>;
    |              ^^^^^^^ ...because method `cleanup` is `async`
...
267 |     async fn prepare_image(&self, language: &str) -> Result<(), SandboxError> {
    |              ^^^^^^^^^^^^^ ...because method `prepare_image` is `async`
    = help: consider moving `execute` to another trait
    = help: consider moving `is_available` to another trait
    = help: consider moving `get_version` to another trait
    = help: consider moving `cleanup` to another trait
    = help: consider moving `prepare_image` to another trait
    = help: the following types implement `SandboxRuntime`:
              sandbox::docker::DockerRuntime
              sandbox::native::NativeRuntime
              sandbox::podman::PodmanRuntime
            consider defining an enum where each variant holds one of these types,
            implementing `SandboxRuntime` for this new enum and using it instead

error[E0282]: type annotations needed
   --> src\screen_recording\recorder.rs:609:31
    |
609 |                 let _ = stdin.write_all(b"q");
    |                               ^^^^^^^^^ cannot infer type for type parameter `T` declared on the enum `Option`

error[E0282]: type annotations needed
   --> src\selection\detector.rs:249:39
    |
249 |                 let orig_clone = orig.clone();
    |                                       ^^^^^ cannot infer type for type parameter `T` declared on the enum `Option`

error[E0282]: type annotations needed
   --> src\selection\detector.rs:262:65
    |
262 |                 log::debug!("Got {} chars from clipboard", text.len());
    |                                                                 ^^^ cannot infer type for type parameter `T` declared on the enum `Option`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `rdev`
   --> src\selection\mouse_hook.rs:148:29
    |
148 |             if let Err(e) = rdev::listen(callback) {
    |                             ^^^^ use of unresolved module or unlinked crate `rdev`
    |
    = help: if you wanted to use a crate named `rdev`, use `cargo add rdev` to add it to your `Cargo.toml`

error[E0282]: type annotations needed
   --> src\selection\history.rs:249:35
    |
249 |                 *by_app.entry(app.clone()).or_insert(0) += 1;
    |                                   ^^^^^ cannot infer type for type parameter `T` declared on the enum `Option`

error[E0282]: type annotations needed
   --> src\selection\history.rs:254:42
    |
254 |                 *by_type.entry(text_type.clone()).or_insert(0) += 1;
    |                                          ^^^^^ cannot infer type for type parameter `T` declared on the enum `Option`

error[E0277]: `McpError` doesn't implement `std::fmt::Display`
   --> src\lib.rs:119:73
    |
119 |                     log::error!("Failed to initialize MCP manager: {}", e);
    |                                                                    --   ^ `McpError` cannot be formatted with the default formatter
    |                                                                    |
    |                                                                    required by this formatting parameter
    |
    = help: the trait `std::fmt::Display` is not implemented for `McpError`
    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
    = note: this error originates in the macro `$crate::__private_api::format_args` which comes from the expansion of the macro `log::error` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0277]: `SandboxError` doesn't implement `std::fmt::Display`
   --> src\lib.rs:162:79
    |
162 |                         log::error!("Failed to initialize sandbox state: {}", e);
    |                                                                          --   ^ `SandboxError` cannot be formatted with the default formatter
    |                                                                          |
    |                                                                          required by this formatting parameter
    |
    = help: the trait `std::fmt::Display` is not implemented for `SandboxError`
    = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
    = note: this error originates in the macro `$crate::__private_api::format_args` which comes from the expansion of the macro `log::error` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `reqwest`
  --> src\mcp\transport\sse.rs:20:13
   |
20 |     client: reqwest::Client,
   |             ^^^^^^^ use of unresolved module or unlinked crate `reqwest`
   |
   = help: if you wanted to use a crate named `reqwest`, use `cargo add reqwest` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `parking_lot`
   --> src\screenshot\mod.rs:100:28
    |
100 |     config: std::sync::Arc<parking_lot::RwLock<ScreenshotConfig>>,
    |                            ^^^^^^^^^^^ use of unresolved module or unlinked crate `parking_lot`
    |
    = help: if you wanted to use a crate named `parking_lot`, use `cargo add parking_lot` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `chrono`
   --> src\sandbox\mod.rs:461:46
    |
461 |         before_date: Option<chrono::DateTime<chrono::Utc>>,
    |                                              ^^^^^^ use of unresolved module or unlinked crate `chrono`
    |
    = help: if you wanted to use a crate named `chrono`, use `cargo add chrono` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `reqwest`
   --> src\commands\proxy.rs:315:31
    |
315 | async fn get_ip_info(client: &reqwest::Client) -> Result<(String, String), String> {
    |                               ^^^^^^^ use of unresolved module or unlinked crate `reqwest`
    |
    = help: if you wanted to use a crate named `reqwest`, use `cargo add reqwest` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `reqwest`
  --> src\http.rs:77:21
   |
77 | ) -> Result<Client, reqwest::Error> {
   |                     ^^^^^^^ use of unresolved module or unlinked crate `reqwest`
   |
   = help: if you wanted to use a crate named `reqwest`, use `cargo add reqwest` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `reqwest`
  --> src\http.rs:99:21
   |
99 | ) -> Result<Client, reqwest::Error> {
   |                     ^^^^^^^ use of unresolved module or unlinked crate `reqwest`
   |
   = help: if you wanted to use a crate named `reqwest`, use `cargo add reqwest` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `chrono`
   --> src\sandbox\mod.rs:461:29
    |
461 |         before_date: Option<chrono::DateTime<chrono::Utc>>,
    |                             ^^^^^^ use of unresolved module or unlinked crate `chrono`
    |
    = help: if you wanted to use a crate named `chrono`, use `cargo add chrono` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `parking_lot`
  --> src\mcp\config.rs:64:13
   |
64 |     config: parking_lot::RwLock<McpConfig>,
   |             ^^^^^^^^^^^ use of unresolved module or unlinked crate `parking_lot`
   |
   = help: if you wanted to use a crate named `parking_lot`, use `cargo add parking_lot` to add it to your `Cargo.toml`

error[E0433]: failed to resolve: use of unresolved module or unlinked crate `reqwest`
  --> src\mcp\error.rs:61:26
   |
61 |     RequestError(#[from] reqwest::Error),
   |                          ^^^^^^^ use of unresolved module or unlinked crate `reqwest`
   |
   = help: if you wanted to use a crate named `reqwest`, use `cargo add reqwest` to add it to your `Cargo.toml`

Some errors have detailed explanations: E0038, E0277, E0282, E0432, E0433, E0599.
For more information about an error, try `rustc --explain E0038`.
warning: `app` (lib) generated 1 warning
error: could not compile `app` (lib) due to 525 previous errors; 1 warning emitted
